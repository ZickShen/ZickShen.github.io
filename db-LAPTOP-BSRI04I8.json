{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/anatole/source/css/blog_basic.css","path":"css/blog_basic.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","path":"js/jquery-migrate-1.2.1.min.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery.appear.js","path":"js/jquery.appear.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo@2x.png","path":"images/logo@2x.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/anatole/.gitignore","hash":"9fcbb05b158b5d3ba1ee60d38889e05e8b0f3f2a","modified":1514225028000},{"_id":"themes/anatole/LICENSE","hash":"359cb81298c1fdbccf531548fc097466b0151be4","modified":1514225028000},{"_id":"themes/anatole/README.md","hash":"75a3829b8a316249ec0b4fd8eae2d371de879494","modified":1514225028000},{"_id":"themes/anatole/_config.sample.yml","hash":"c6bce49d93a37e9ed5f0c4b104decc0bd7832e04","modified":1514225028000},{"_id":"themes/anatole/package.json","hash":"cf731a3ebf3913747fccb6c4c6615eba7d7e88a4","modified":1514225028000},{"_id":"source/_posts/README","hash":"05fcbe544d395e48bba9c2aeeb92ff5cbe48c23a","modified":1521479629000},{"_id":"source/_posts/Go学习笔记.md","hash":"e62cb8a65cf2d5cd35bd374444de1e90260ece1f","modified":1519137159000},{"_id":"source/_posts/code.zip","hash":"c53fca0667e98280fbf1fa933e4fe0061ebceecf","modified":1521544636000},{"_id":"source/_posts/flowchart.png","hash":"0063a19dc1e6f1fedc833749a54befda05b6bb5b","modified":1521470396000},{"_id":"source/_posts/main.c","hash":"c31e0cc736debfb000935c763096e9877ebdbe10","modified":1521544337000},{"_id":"source/_posts/snipaste20180320_005219.png","hash":"6be177b6767547f4a5bb21d639d8fdfba825f296","modified":1521478348000},{"_id":"source/_posts/multithread.c","hash":"58ba8de76e9d7ce7abb2e978da60c4c16781098a","modified":1521543699000},{"_id":"source/_posts/区块链学习笔记（一）.md","hash":"012b0547cc7e154defe31652dd3aedb1e9d47597","modified":1521124644000},{"_id":"source/_posts/区块链学习笔记（二）.md","hash":"347a8599a00d6926d06304c40807fc4358b1d268","modified":1521124630000},{"_id":"source/_posts/完成一个C语言http服务器压力测试工具（一）.md","hash":"11bccd2c8b9205569ae349ee9ce59972880464dd","modified":1521472559000},{"_id":"source/_posts/完成一个C语言http服务器压力测试工具（三）.md","hash":"5824c9c58143d5579b9e0a25e69e637d416acb73","modified":1523171613000},{"_id":"source/_posts/完成一个C语言http服务器压力测试工具（二）.md","hash":"ab919a9db9f5c817406d6f1daec9889a86e22735","modified":1521307510000},{"_id":"source/_posts/新坑挖填状态.md","hash":"64d0f2058ff972b47d022aa9d5192e5c3eefdb92","modified":1519196033000},{"_id":"source/about/index.md","hash":"54402f5be4192a4faa1199d3d2f115e9669b6bac","modified":1517743002000},{"_id":"source/links/index.md","hash":"28c552dfcd0c2615bfad8c322d988442e95e1bb7","modified":1517743005000},{"_id":"source/categories/index.md","hash":"59fc34c3a8325014fea50b98e103912ea1cd83bd","modified":1517661164000},{"_id":"source/tags/index.md","hash":"0d8e78b4f7a737aa8efa55273cdf63f5d2f7d2b9","modified":1517661191000},{"_id":"themes/anatole/languages/pt-BR.yml","hash":"ac5a0003d7793aade51f70643b2e2a631b6a65c3","modified":1514225028000},{"_id":"themes/anatole/languages/zh-cn.yml","hash":"dab1823e036f4adb3b7ae9efe95a37a15e47bec2","modified":1514225028000},{"_id":"themes/anatole/layout/archive.pug","hash":"1a161404966000b25a84762f08da3ca60af146bc","modified":1514225028000},{"_id":"themes/anatole/layout/category.pug","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1514225028000},{"_id":"themes/anatole/layout/index.pug","hash":"53da3cfd498951148acb33de1574df80ae282dc5","modified":1514225028000},{"_id":"themes/anatole/layout/mixins.pug","hash":"107bfd2fe10de0d8b110c13bb1168af79e62a37c","modified":1514225028000},{"_id":"themes/anatole/layout/page.pug","hash":"15142c94e5c2247aba8efb64cffd695b3f133670","modified":1514225028000},{"_id":"themes/anatole/layout/post.pug","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1514225028000},{"_id":"themes/anatole/layout/tag.pug","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1514225028000},{"_id":"source/_posts/区块链学习笔记（一）/2.jpg","hash":"a617bfe2ec6cda737dd29eec07370fa24d5527d3","modified":1516207733000},{"_id":"source/_posts/区块链学习笔记（一）/snipaste20180118_002602.jpg","hash":"9583e047202b90098116925b61cefcb9b9c7bddd","modified":1516206374000},{"_id":"source/_posts/区块链学习笔记（一）/snipaste20180118_013210.jpg","hash":"aa39c6b432353034b36fdb01006bc12931634a12","modified":1516210332000},{"_id":"source/_posts/区块链学习笔记（一）/snipaste20180118_004710.jpg","hash":"45868859ef7ad0634c3226e1275d33e142ea6e86","modified":1516207686000},{"_id":"source/_posts/区块链学习笔记（二）/snipaste20180122_154420.jpg","hash":"b8ffe368453275fd404281b8fade32cd671ace8a","modified":1516610978000},{"_id":"source/_posts/完成一个C语言http服务器压力测试工具（三）/flowchart.png","hash":"0063a19dc1e6f1fedc833749a54befda05b6bb5b","modified":1521470396000},{"_id":"source/_posts/完成一个C语言http服务器压力测试工具（三）/snipaste20180320_005219.png","hash":"6be177b6767547f4a5bb21d639d8fdfba825f296","modified":1521478348000},{"_id":"themes/anatole/source/css/blog_basic.css","hash":"7db88f0873e858b21a4c981c8481708ad9117478","modified":1514225028000},{"_id":"themes/anatole/source/css/font-awesome.min.css","hash":"95d0b0c4d11105c81be1857b744076a1d2bed918","modified":1514225028000},{"_id":"themes/anatole/source/css/style.css","hash":"871a5c940cbc0ce5488a670f2285f2c3015cf71c","modified":1514225028000},{"_id":"themes/anatole/source/css/style.scss","hash":"175c9237798207f705c62777b5f51509adec6d0a","modified":1514225028000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1514225028000},{"_id":"themes/anatole/source/images/favicon.png","hash":"b3721728a5ce77851596aaa5834eb577ac8a5700","modified":1517663718000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1514225028000},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1514225028000},{"_id":"themes/anatole/source/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1514225028000},{"_id":"themes/anatole/layout/partial/footer.pug","hash":"772f03a2dd9fa4fed422c4eb4d5d1ace84c65580","modified":1514225028000},{"_id":"themes/anatole/layout/partial/head.pug","hash":"3d6126d0b53a889a46ad61eb8cc0ab1b35446c49","modified":1514225028000},{"_id":"themes/anatole/layout/partial/comments.pug","hash":"fad5bbe7c2a134c892fcb1c731d979463145a49b","modified":1514225028000},{"_id":"themes/anatole/layout/partial/layout.pug","hash":"174050fa9ee919f5bcb2c5426224ec1968db672c","modified":1514225028000},{"_id":"themes/anatole/layout/partial/nav.pug","hash":"6ef30551de7b22d99b6a0980caf7899d7c303093","modified":1514225028000},{"_id":"themes/anatole/layout/partial/sidebar.pug","hash":"6721b1e0b1e59e54d031a4978e7f82aece336efc","modified":1514225028000},{"_id":"source/_posts/完成一个C语言http服务器压力测试工具（一）/FD_SIZE.png","hash":"ecd641a6abe9a30330e5d290bc59d0bec2cb326e","modified":1521286190000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1514225028000},{"_id":"themes/anatole/source/images/logo.png","hash":"f5828538805223a53c6bb83518ce722a23de378f","modified":1517663689000},{"_id":"themes/anatole/source/images/logo@2x.png","hash":"f5828538805223a53c6bb83518ce722a23de378f","modified":1517663689000},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1514225028000},{"_id":"themes/anatole/source/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1514225028000},{"_id":"source/_posts/区块链学习笔记（一）/新文档_2018-01-18_1.jpg","hash":"d58c475bb7eeed0bac49eddedc616f4e40940efc","modified":1516214849000},{"_id":"public/tags/index.html","hash":"99e41f0435ce5abbfc09647525d8a25efc2cecd3","modified":1525359713775},{"_id":"public/about/index.html","hash":"fac88221b2535e644c19f17d0e8e2c7aa5efa61a","modified":1525359713783},{"_id":"public/atom.xml","hash":"8c3b966f9efbff7be442c2ddf7e65a3e24ebe130","modified":1525359713784},{"_id":"public/categories/index.html","hash":"a1e40f13d93bece16ab4cfee629604fdbf5bf5b1","modified":1525359713794},{"_id":"public/links/index.html","hash":"7ee3e472b3626c500c3125ed79d59318e6a5a3bb","modified":1525359713795},{"_id":"public/2018/01/20/区块链学习笔记（一）/index.html","hash":"7071efc6de14bda81e5ba908287456e7cc2b1d53","modified":1525359713795},{"_id":"public/archives/index.html","hash":"e6ea1a215fe9c43a14ac810b78f39374639993c0","modified":1525359713795},{"_id":"public/categories/Notes/index.html","hash":"b4fc4d949b1aeab8c920780a85d2bdc94d8614e6","modified":1525359713795},{"_id":"public/tags/Programming/index.html","hash":"f4055e0cea37e2212e08cef04adcbc65a5aa160d","modified":1525359713795},{"_id":"public/tags/blockchain/index.html","hash":"eddc301997aeda1ead8ade486171bb8ad13b773a","modified":1525359713796},{"_id":"public/index.html","hash":"60783ec3a1e8347e8d1a40288c1e985ef426f4d5","modified":1525359713796},{"_id":"public/tags/C/index.html","hash":"8d9b87176f31d4c8d908f17c1184b166815bf92c","modified":1525359713796},{"_id":"public/tags/Software-Development/index.html","hash":"9461236d52b43bd10af77185291b27f0f4ff6129","modified":1525359713796},{"_id":"public/tags/Tools/index.html","hash":"9ce524739f875b1e6b47f1a64e2e2dd0532f7dac","modified":1525359713796},{"_id":"public/2018/02/17/新坑挖填状态/index.html","hash":"1e5e12c0e50ee6e988a4b2bf701c0a2bd8774886","modified":1525359713796},{"_id":"public/2018/03/19/完成一个C语言http服务器压力测试工具（三）/index.html","hash":"65413ea883448df830a5ff9032b78b38d93cf41d","modified":1525359713796},{"_id":"public/2018/03/18/完成一个C语言http服务器压力测试工具（二）/index.html","hash":"c3bb309323388557341ba5424dbf0892db6eefaf","modified":1525359713796},{"_id":"public/2018/03/15/完成一个C语言http服务器压力测试工具（一）/index.html","hash":"0aafa6b5dc1d61e711e6fbd41b72e9eb28b60b29","modified":1525359713797},{"_id":"public/2018/02/20/Go学习笔记/index.html","hash":"9a34993fc4574bca6e6e73641f8e063c52cf08d6","modified":1525359713797},{"_id":"public/2018/01/21/区块链学习笔记（二）/index.html","hash":"44a270c3e36ef870db5eccb3f34fcae32d467b76","modified":1525359713797},{"_id":"public/css/style.scss","hash":"175c9237798207f705c62777b5f51509adec6d0a","modified":1525359713797},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1525359713797},{"_id":"public/images/favicon.png","hash":"b3721728a5ce77851596aaa5834eb577ac8a5700","modified":1525359713797},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1525359713797},{"_id":"public/2018/03/19/完成一个C语言http服务器压力测试工具（三）/flowchart.png","hash":"0063a19dc1e6f1fedc833749a54befda05b6bb5b","modified":1525359713798},{"_id":"public/2018/01/21/区块链学习笔记（二）/snipaste20180122_154420.jpg","hash":"b8ffe368453275fd404281b8fade32cd671ace8a","modified":1525359713798},{"_id":"public/2018/03/19/完成一个C语言http服务器压力测试工具（三）/snipaste20180320_005219.png","hash":"6be177b6767547f4a5bb21d639d8fdfba825f296","modified":1525359713798},{"_id":"public/2018/01/20/区块链学习笔记（一）/2.jpg","hash":"a617bfe2ec6cda737dd29eec07370fa24d5527d3","modified":1525359713798},{"_id":"public/2018/01/20/区块链学习笔记（一）/snipaste20180118_002602.jpg","hash":"9583e047202b90098116925b61cefcb9b9c7bddd","modified":1525359713798},{"_id":"public/2018/01/20/区块链学习笔记（一）/snipaste20180118_004710.jpg","hash":"45868859ef7ad0634c3226e1275d33e142ea6e86","modified":1525359713798},{"_id":"public/2018/01/20/区块链学习笔记（一）/snipaste20180118_013210.jpg","hash":"aa39c6b432353034b36fdb01006bc12931634a12","modified":1525359713798},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1525359713807},{"_id":"public/2018/03/15/完成一个C语言http服务器压力测试工具（一）/FD_SIZE.png","hash":"ecd641a6abe9a30330e5d290bc59d0bec2cb326e","modified":1525359713809},{"_id":"public/css/style.css","hash":"871a5c940cbc0ce5488a670f2285f2c3015cf71c","modified":1525359713815},{"_id":"public/css/blog_basic.css","hash":"7db88f0873e858b21a4c981c8481708ad9117478","modified":1525359713815},{"_id":"public/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1525359713815},{"_id":"public/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1525359713815},{"_id":"public/css/font-awesome.min.css","hash":"95d0b0c4d11105c81be1857b744076a1d2bed918","modified":1525359713815},{"_id":"public/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1525359713815},{"_id":"public/images/logo.png","hash":"f5828538805223a53c6bb83518ce722a23de378f","modified":1525359713817},{"_id":"public/images/logo@2x.png","hash":"f5828538805223a53c6bb83518ce722a23de378f","modified":1525359713817},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1525359713848},{"_id":"public/2018/01/20/区块链学习笔记（一）/新文档_2018-01-18_1.jpg","hash":"d58c475bb7eeed0bac49eddedc616f4e40940efc","modified":1525359713851}],"Category":[{"name":"Notes","_id":"cjgqnscz60001dkud24g4qt0f"}],"Data":[],"Page":[{"title":"All tags","date":"2018-02-03T12:31:47.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ndate: 2018-02-03 20:31:47\ntype: \"tags\"\n---\n","updated":"2018-02-03T12:33:11.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjgqnsczm0006dkudy7ppmph4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2018-02-04T11:13:25.000Z","_content":"\nHappy to meet you~\n\nWhy not sit and have a coffee now?","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-02-04 19:13:25\n---\n\nHappy to meet you~\n\nWhy not sit and have a coffee now?","updated":"2018-02-04T11:16:42.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjgqnsczm0008dkudrl2l43cq","content":"<p>Happy to meet you~</p>\n<p>Why not sit and have a coffee now?</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Happy to meet you~</p>\n<p>Why not sit and have a coffee now?</p>\n"},{"title":"All categories","date":"2018-02-03T12:32:06.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: All categories\ndate: 2018-02-03 20:32:06\ntype: \"categories\"\n---\n","updated":"2018-02-03T12:32:44.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjgqnsczr000bdkudkupzaoib","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"links","date":"2018-02-04T11:13:04.000Z","_content":"\n\n\nCSUwangj: https://csuwangj.github.io/","source":"links/index.md","raw":"---\ntitle: links\ndate: 2018-02-04 19:13:04\n---\n\n\n\nCSUwangj: https://csuwangj.github.io/","updated":"2018-02-04T11:16:45.000Z","path":"links/index.html","comments":1,"layout":"page","_id":"cjgqnsczu000edkuduu28wdry","content":"<p>CSUwangj: <a href=\"https://csuwangj.github.io/\" target=\"_blank\" rel=\"noopener\">https://csuwangj.github.io/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>CSUwangj: <a href=\"https://csuwangj.github.io/\" target=\"_blank\" rel=\"noopener\">https://csuwangj.github.io/</a></p>\n"}],"Post":[{"title":"Go学习笔记","connments":true,"date":"2018-02-20T09:12:49.000Z","desc":"学习Go的笔记","summary":"学习Go的笔记，方便使用做的","_content":"# 学习资料：\n首推官方https://tour.go-zh.org/welcome/1\n其次http://www.runoob.com/go/go-tutorial.html\n\n# 瞎写的笔记\n\n## 基本结构\n\n```go\npackage main //必须在源文件中非注释的第一行指明这个文件属于哪个包，\n\t\t\t//每个 Go 应用程序都包含一个名为 main 的包。\n\nimport \"fmt\" //使用该包\n\t\t\t//fmt 包实现了格式化 IO（输入/输出）的函数。\nimport(\n\t\"fmt\"\n    \"math\"\t//分组导入语句\n)\n\nfunc main() {\n    \t\t//注释和C语言是一样的\n   fmt.Println(\"Hello, World!\")//效果和Java的Println是一个效果，但句末不需分号\n   \t\t\t\t\t\t\t//当同一行有多个语句时，用分号分隔，但不推荐\n}\n```\n\nGo的Hello World\n\n## 变量\n\n```go\n//当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：\nvar Group1 int//定义形式\n//那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）\n//标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。\n/*\n *\tGo中的基本类型：\n *\t数字类型(u)int8/16/32/64\n *\t浮点型float32/64,complex64/128\n *\t其他：byte uint8 的别名\n *\t\t rune int32 的别名, 表示一个 Unicode 码点 \n *\t\t uint 32 or 64bit\n *\t\t int  same as uint\n *\t\t uintprt 无符号整型，用于存放一个指针\n */\nvar a = 2 int//这种定义会出错\nvar a = 2\t//没问题\nvar a int\t//没问题\nvar a int =2//没问题\n\n//没有明确初始值的变量声明会被赋予它们的零值。\n//零值是：\n//数值类型为 0 ，\n//布尔类型为 false ，\n//字符串为 \"\" （空字符串）。\n\n//三种定义形式\nvar a int\nvar a = 2//交给Go自己判断\na := 2\t//左侧变量不应被提前声明过\n\n//与Python类似的多变量声明\n\na, b, c := 1, 2, 3\n\n//一次声明多个不同类型的变量\nvar (\n\ta int\n    b bool\n)\n\nvar e, f = 123, \"hello\"\n\n//这种只能在函数体中出现\ng, h := 123, \"hello\"\n//全局变量允许声明但不实用，局部变量声明不使用会报错\n//因为函数外的每个语句都必须以关键字开始（ var 、 func 等等）\n\n//常量定义格式\nconst identifier [type] = value\n\n//用作枚举\nconst (\n\tFirst = 0\n    Second = 1\n    Other = 2\n)\n```\n```go\n//特殊常量iota\n//在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    const (\n            a = iota   //0\n            b          //1\n            c          //2\n            d = \"ha\"   //独立值，iota += 1\n            e          //\"ha\"   iota += 1\n            f = 100    //iota +=1\n            g          //100  iota +=1\n            h = iota   //7,恢复计数\n            i          //8\n    )\n    fmt.Println(a,b,c,d,e,f,g,h,i)\n}\n```\n\n不同类型的数值没有隐式转换\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main(){\n\tvar a int8\n\tvar b int64\n\ta = 123\n\tb = 1234567890123456\n\tfmt.Println(a^b, a+b, b-a)\n}\n//λ go run math.go\n//# command-line-arguments\n//.\\math.go:10:15: invalid operation: a ^ b (mismatched types int8 and int64)\n//.\\math.go:10:20: invalid operation: a + b (mismatched types int8 and int64)\n//.\\math.go:10:25: invalid operation: b - a (mismatched types int64 and int8)\n```\n\n指针变量\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main(){\n\tvar a int = 4\n\tvar ptr *int\n\tptr = &a    /* 'ptr' 包含了 'a' 变量的地址 */\n\tfmt.Printf(\"a 的值为  %d\\n\", a)\n\tfmt.Printf(\"*ptr 为 %d\\n\", *ptr)\n\tfmt.Println(\"ptr的值为%p\",ptr)\n}\n//a 的值为  4\n//*ptr 为 4\n//ptr的值为%p 0xc042060058\n```\n## 运算符优先级\n| 优先级     | 运算符                 |\n| ---- | ---------------- |\n| 7    | ^ !              |\n| 6    | * / % << >> & &^ |\n| 5    | + - \\| ^         |\n| 4    | == != < <= >= >  |\n| 3    | <-               |\n| 2    | &&               |\n| 1    | \\|\\|             |\n\n## 条件语句\n\nif类似for，没有小括号，大括号必须，同时在条件表达式前执行语句可以声明变量，该语句声明的变量作用域仅在 if 之内。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t} else {\n\t\tfmt.Printf(\"%g >= %g\\n\", v, lim)\n\t}\n\t// 这里开始就不能使用 v 了\n\treturn lim\n}\n\nfunc main() {\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n\n```\n\nswitch同理\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\nfunc main() {\n\tfmt.Print(\"Go runs on \")\n\tswitch os := runtime.GOOS; os {\n\tcase \"darwin\":\n\t\tfmt.Println(\"OS X.\")\n\tcase \"linux\":\n\t\tfmt.Println(\"Linux.\")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf(\"%s.\", os)\n\t}\n}\n//switch的case从上到下顺次执行，匹配成功时停止\n```\n\nswitch可以没有条件，用起来相当于if-then-else\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tt := time.Now()\n\tswitch {\n\tcase t.Hour() < 12:\n\t\tfmt.Println(\"Good morning!\")\n\tcase t.Hour() < 17:\n\t\tfmt.Println(\"Good afternoon.\")\n\tdefault:\n\t\tfmt.Println(\"Good evening.\")\n\t}\n}\n```\n\ndefer 语句会将函数推迟到外层函数返回之后执行。\n\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\n推迟的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n\n更多关于 defer 语句的信息， 请阅读[此博文](http://blog.go-zh.org/defer-panic-and-recover)。（感觉这个特性很有意思，但是是深坑的既视感）\n\n### 神奇的select\n\n之后补\n\n## 循环\n\n```go\n//Go中只有for循环\n//基本的 for 循环由三部分组成，它们用分号隔开：\n\n//初始化语句：在第一次迭代前执行\n//条件表达式：在每次迭代前求值\n//后置语句：在每次迭代的结尾执行\n//初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。\n\n//一旦条件表达式的布尔值为 false，循环迭代就会终止。 注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面没有小括号，大括号 { } 则是必须的。\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i < 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.Println(sum)\n}\n//55\n```\n\n初始化语句与后置语句是可选的部分\n\n省略循环条件表示无限循环\n\n## 函数\n\n函数可以没有参数或接受多个参数，返回任意数量的返回值，如\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc add(x int, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n```\n\n同时当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n```\n\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n\n返回值的名称应当具有一定的意义，它可以作为文档使用。\n\n# 结构体\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n}\n//如果有指向结构体的指针那么可以通过 (*p).X 来访问其字段 X 。 不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。\n//结构体文法通过直接列出字段的值来新分配一个结构体。\nvar\tv1 = Vertex{1, 2}  // has type Vertex\n//使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）\nvar v2 = Vertex{X: 1}  // Y:0 is implicit\n//特殊的前缀 & 返回一个指向结构体的指针。\nvar p  = &Vertex{1, 2} // has type *Vertex\n```\n\n# 数组\n\n类型 `[n]T` 表示拥有 `n` 个 `T` 类型的值的数组。\n\n如：var a [10]int\n\n和Python类似的切片用法，但是只返回引用切片文法\n\n切片文法类似于没有长度的数组文法。\n\n这是一个数组文法：\n\n```\n[3]bool{true, true, false}\n```\n\n下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：\n\n```\n[]bool{true, true, false}\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tq := []int{2, 3, 5, 7, 11, 13}\n\tfmt.Println(q)\n\n\tr := []bool{true, false, true, true, false, true}\n\tfmt.Println(r)\n\n\ts := []struct {\n\t\ti int\n\t\tb bool\n\t}{\n\t\t{2, true},\n\t\t{3, false},\n\t\t{5, true},\n\t\t{7, true},\n\t\t{11, false},\n\t\t{13, true},\n\t}\n\tfmt.Println(s)\n}\n//[2 3 5 7 11 13]\n//[true false true true false true]\n//[{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]\n```\n\n切片拥有 **长度** 和 **容量** 。\n\n切片的长度就是它所包含的元素个数。\n\n切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。\n\n切片 `s` 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取。\n\n你可以通过重新切片来扩展一个切片，给它提供足够的容量。 试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\tprintSlice(s)\n\n\t// Slice the slice to give it zero length.\n\ts = s[:0]\n\tprintSlice(s)\n\n\t// Extend its length.\n\ts = s[:4]\n\tprintSlice(s)\n\n\t// Drop its first two values.\n\ts = s[2:]\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n//len=6 cap=6 [2 3 5 7 11 13]\n//len=0 cap=6 []\n//len=4 cap=6 [2 3 5 7]\n//len=2 cap=4 [5 7]\n```\n\n切片的零值是 `nil` 。\n\nnil 切片的长度和容量为 0 且没有底层数组\n\n切面可以用内建函数 `make` 来创建，这也是你创建动态数组的方式。\n\n`make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：\n\n```\na := make([]int, 5)  // len(a)=5\n```\n\n要指定它的容量，需向 `make` 传入第三个参数：\n\n```\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n\nb = b[:cap(b)] // len(b)=5, cap(b)=5\nb = b[1:]      // len(b)=4, cap(b)=4\n```\n\nrange for 每次迭代返回两个值，一个值为当前元素的下标，另一个值为该下标所对应元素的一份副本。\n\n```go\npackage main\n\nimport \"fmt\"\n\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n\nfunc main() {\n\tfor i, v := range pow {\n\t\tfmt.Printf(\"2**%d = %d\\n\", i, v)\n\t}\n}\n//2**0 = 1\n//2**1 = 2\n//2**2 = 4\n//2**3 = 8\n//2**4 = 16\n//2**5 = 32\n//2**6 = 64\n//2**7 = 128\n```\n\n可以将下标或值赋予 `_` 来忽略它。\n\n# 映射\n\n就是map\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": Vertex{\n\t\t40.68433, -74.39967,\n\t},\n\t\"Google\": Vertex{\n\t\t37.42202, -122.08408,\n\t},\n}\n\nfunc main() {\n\tfmt.Println(m)\n}\n//map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]\n```\n\n# 闭包\n\nGo 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。\n\n例如，函数 `adder` 返回一个闭包。每个闭包都被绑定在其各自的 `sum` 变量上。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc adder() func(int) int {\n\tsum := 0\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\tpos, neg := adder(), adder()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(\n\t\t\tpos(i),\n\t\t\tneg(-2*i),\n\t\t)\n\t}\n}\n//0 0\n//1 -2\n//3 -6\n//6 -12\n//10 -20\n//15 -30\n//21 -42\n//28 -56\n//36 -72\n//45 -90\n```\n\n函数式编程啊！但是我不会啊！等我看完SICP再来！（滑稽XD\n\n","source":"_posts/Go学习笔记.md","raw":"---\ntitle: Go学习笔记\nconnments: true\ndate: 2018-02-20 17:12:49\ntags: Programming\ncategories: Notes\ndesc: 学习Go的笔记\nsummary: 学习Go的笔记，方便使用做的\n---\n# 学习资料：\n首推官方https://tour.go-zh.org/welcome/1\n其次http://www.runoob.com/go/go-tutorial.html\n\n# 瞎写的笔记\n\n## 基本结构\n\n```go\npackage main //必须在源文件中非注释的第一行指明这个文件属于哪个包，\n\t\t\t//每个 Go 应用程序都包含一个名为 main 的包。\n\nimport \"fmt\" //使用该包\n\t\t\t//fmt 包实现了格式化 IO（输入/输出）的函数。\nimport(\n\t\"fmt\"\n    \"math\"\t//分组导入语句\n)\n\nfunc main() {\n    \t\t//注释和C语言是一样的\n   fmt.Println(\"Hello, World!\")//效果和Java的Println是一个效果，但句末不需分号\n   \t\t\t\t\t\t\t//当同一行有多个语句时，用分号分隔，但不推荐\n}\n```\n\nGo的Hello World\n\n## 变量\n\n```go\n//当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：\nvar Group1 int//定义形式\n//那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）\n//标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。\n/*\n *\tGo中的基本类型：\n *\t数字类型(u)int8/16/32/64\n *\t浮点型float32/64,complex64/128\n *\t其他：byte uint8 的别名\n *\t\t rune int32 的别名, 表示一个 Unicode 码点 \n *\t\t uint 32 or 64bit\n *\t\t int  same as uint\n *\t\t uintprt 无符号整型，用于存放一个指针\n */\nvar a = 2 int//这种定义会出错\nvar a = 2\t//没问题\nvar a int\t//没问题\nvar a int =2//没问题\n\n//没有明确初始值的变量声明会被赋予它们的零值。\n//零值是：\n//数值类型为 0 ，\n//布尔类型为 false ，\n//字符串为 \"\" （空字符串）。\n\n//三种定义形式\nvar a int\nvar a = 2//交给Go自己判断\na := 2\t//左侧变量不应被提前声明过\n\n//与Python类似的多变量声明\n\na, b, c := 1, 2, 3\n\n//一次声明多个不同类型的变量\nvar (\n\ta int\n    b bool\n)\n\nvar e, f = 123, \"hello\"\n\n//这种只能在函数体中出现\ng, h := 123, \"hello\"\n//全局变量允许声明但不实用，局部变量声明不使用会报错\n//因为函数外的每个语句都必须以关键字开始（ var 、 func 等等）\n\n//常量定义格式\nconst identifier [type] = value\n\n//用作枚举\nconst (\n\tFirst = 0\n    Second = 1\n    Other = 2\n)\n```\n```go\n//特殊常量iota\n//在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    const (\n            a = iota   //0\n            b          //1\n            c          //2\n            d = \"ha\"   //独立值，iota += 1\n            e          //\"ha\"   iota += 1\n            f = 100    //iota +=1\n            g          //100  iota +=1\n            h = iota   //7,恢复计数\n            i          //8\n    )\n    fmt.Println(a,b,c,d,e,f,g,h,i)\n}\n```\n\n不同类型的数值没有隐式转换\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main(){\n\tvar a int8\n\tvar b int64\n\ta = 123\n\tb = 1234567890123456\n\tfmt.Println(a^b, a+b, b-a)\n}\n//λ go run math.go\n//# command-line-arguments\n//.\\math.go:10:15: invalid operation: a ^ b (mismatched types int8 and int64)\n//.\\math.go:10:20: invalid operation: a + b (mismatched types int8 and int64)\n//.\\math.go:10:25: invalid operation: b - a (mismatched types int64 and int8)\n```\n\n指针变量\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main(){\n\tvar a int = 4\n\tvar ptr *int\n\tptr = &a    /* 'ptr' 包含了 'a' 变量的地址 */\n\tfmt.Printf(\"a 的值为  %d\\n\", a)\n\tfmt.Printf(\"*ptr 为 %d\\n\", *ptr)\n\tfmt.Println(\"ptr的值为%p\",ptr)\n}\n//a 的值为  4\n//*ptr 为 4\n//ptr的值为%p 0xc042060058\n```\n## 运算符优先级\n| 优先级     | 运算符                 |\n| ---- | ---------------- |\n| 7    | ^ !              |\n| 6    | * / % << >> & &^ |\n| 5    | + - \\| ^         |\n| 4    | == != < <= >= >  |\n| 3    | <-               |\n| 2    | &&               |\n| 1    | \\|\\|             |\n\n## 条件语句\n\nif类似for，没有小括号，大括号必须，同时在条件表达式前执行语句可以声明变量，该语句声明的变量作用域仅在 if 之内。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t} else {\n\t\tfmt.Printf(\"%g >= %g\\n\", v, lim)\n\t}\n\t// 这里开始就不能使用 v 了\n\treturn lim\n}\n\nfunc main() {\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n\n```\n\nswitch同理\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\nfunc main() {\n\tfmt.Print(\"Go runs on \")\n\tswitch os := runtime.GOOS; os {\n\tcase \"darwin\":\n\t\tfmt.Println(\"OS X.\")\n\tcase \"linux\":\n\t\tfmt.Println(\"Linux.\")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf(\"%s.\", os)\n\t}\n}\n//switch的case从上到下顺次执行，匹配成功时停止\n```\n\nswitch可以没有条件，用起来相当于if-then-else\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tt := time.Now()\n\tswitch {\n\tcase t.Hour() < 12:\n\t\tfmt.Println(\"Good morning!\")\n\tcase t.Hour() < 17:\n\t\tfmt.Println(\"Good afternoon.\")\n\tdefault:\n\t\tfmt.Println(\"Good evening.\")\n\t}\n}\n```\n\ndefer 语句会将函数推迟到外层函数返回之后执行。\n\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\n推迟的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n\n更多关于 defer 语句的信息， 请阅读[此博文](http://blog.go-zh.org/defer-panic-and-recover)。（感觉这个特性很有意思，但是是深坑的既视感）\n\n### 神奇的select\n\n之后补\n\n## 循环\n\n```go\n//Go中只有for循环\n//基本的 for 循环由三部分组成，它们用分号隔开：\n\n//初始化语句：在第一次迭代前执行\n//条件表达式：在每次迭代前求值\n//后置语句：在每次迭代的结尾执行\n//初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。\n\n//一旦条件表达式的布尔值为 false，循环迭代就会终止。 注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面没有小括号，大括号 { } 则是必须的。\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i < 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.Println(sum)\n}\n//55\n```\n\n初始化语句与后置语句是可选的部分\n\n省略循环条件表示无限循环\n\n## 函数\n\n函数可以没有参数或接受多个参数，返回任意数量的返回值，如\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc add(x int, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n```\n\n同时当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n```\n\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n\n返回值的名称应当具有一定的意义，它可以作为文档使用。\n\n# 结构体\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n}\n//如果有指向结构体的指针那么可以通过 (*p).X 来访问其字段 X 。 不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。\n//结构体文法通过直接列出字段的值来新分配一个结构体。\nvar\tv1 = Vertex{1, 2}  // has type Vertex\n//使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）\nvar v2 = Vertex{X: 1}  // Y:0 is implicit\n//特殊的前缀 & 返回一个指向结构体的指针。\nvar p  = &Vertex{1, 2} // has type *Vertex\n```\n\n# 数组\n\n类型 `[n]T` 表示拥有 `n` 个 `T` 类型的值的数组。\n\n如：var a [10]int\n\n和Python类似的切片用法，但是只返回引用切片文法\n\n切片文法类似于没有长度的数组文法。\n\n这是一个数组文法：\n\n```\n[3]bool{true, true, false}\n```\n\n下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：\n\n```\n[]bool{true, true, false}\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tq := []int{2, 3, 5, 7, 11, 13}\n\tfmt.Println(q)\n\n\tr := []bool{true, false, true, true, false, true}\n\tfmt.Println(r)\n\n\ts := []struct {\n\t\ti int\n\t\tb bool\n\t}{\n\t\t{2, true},\n\t\t{3, false},\n\t\t{5, true},\n\t\t{7, true},\n\t\t{11, false},\n\t\t{13, true},\n\t}\n\tfmt.Println(s)\n}\n//[2 3 5 7 11 13]\n//[true false true true false true]\n//[{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]\n```\n\n切片拥有 **长度** 和 **容量** 。\n\n切片的长度就是它所包含的元素个数。\n\n切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。\n\n切片 `s` 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取。\n\n你可以通过重新切片来扩展一个切片，给它提供足够的容量。 试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\tprintSlice(s)\n\n\t// Slice the slice to give it zero length.\n\ts = s[:0]\n\tprintSlice(s)\n\n\t// Extend its length.\n\ts = s[:4]\n\tprintSlice(s)\n\n\t// Drop its first two values.\n\ts = s[2:]\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n//len=6 cap=6 [2 3 5 7 11 13]\n//len=0 cap=6 []\n//len=4 cap=6 [2 3 5 7]\n//len=2 cap=4 [5 7]\n```\n\n切片的零值是 `nil` 。\n\nnil 切片的长度和容量为 0 且没有底层数组\n\n切面可以用内建函数 `make` 来创建，这也是你创建动态数组的方式。\n\n`make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：\n\n```\na := make([]int, 5)  // len(a)=5\n```\n\n要指定它的容量，需向 `make` 传入第三个参数：\n\n```\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n\nb = b[:cap(b)] // len(b)=5, cap(b)=5\nb = b[1:]      // len(b)=4, cap(b)=4\n```\n\nrange for 每次迭代返回两个值，一个值为当前元素的下标，另一个值为该下标所对应元素的一份副本。\n\n```go\npackage main\n\nimport \"fmt\"\n\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n\nfunc main() {\n\tfor i, v := range pow {\n\t\tfmt.Printf(\"2**%d = %d\\n\", i, v)\n\t}\n}\n//2**0 = 1\n//2**1 = 2\n//2**2 = 4\n//2**3 = 8\n//2**4 = 16\n//2**5 = 32\n//2**6 = 64\n//2**7 = 128\n```\n\n可以将下标或值赋予 `_` 来忽略它。\n\n# 映射\n\n就是map\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": Vertex{\n\t\t40.68433, -74.39967,\n\t},\n\t\"Google\": Vertex{\n\t\t37.42202, -122.08408,\n\t},\n}\n\nfunc main() {\n\tfmt.Println(m)\n}\n//map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]\n```\n\n# 闭包\n\nGo 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。\n\n例如，函数 `adder` 返回一个闭包。每个闭包都被绑定在其各自的 `sum` 变量上。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc adder() func(int) int {\n\tsum := 0\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\tpos, neg := adder(), adder()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(\n\t\t\tpos(i),\n\t\t\tneg(-2*i),\n\t\t)\n\t}\n}\n//0 0\n//1 -2\n//3 -6\n//6 -12\n//10 -20\n//15 -30\n//21 -42\n//28 -56\n//36 -72\n//45 -90\n```\n\n函数式编程啊！但是我不会啊！等我看完SICP再来！（滑稽XD\n\n","slug":"Go学习笔记","published":1,"updated":"2018-02-20T14:32:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgqnscyv0000dkudn8zoj7rk","content":"<h1 id=\"学习资料：\"><a href=\"#学习资料：\" class=\"headerlink\" title=\"学习资料：\"></a>学习资料：</h1><p>首推官方<a href=\"https://tour.go-zh.org/welcome/1\" target=\"_blank\" rel=\"noopener\">https://tour.go-zh.org/welcome/1</a><br>其次<a href=\"http://www.runoob.com/go/go-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/go/go-tutorial.html</a></p>\n<h1 id=\"瞎写的笔记\"><a href=\"#瞎写的笔记\" class=\"headerlink\" title=\"瞎写的笔记\"></a>瞎写的笔记</h1><h2 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main <span class=\"comment\">//必须在源文件中非注释的第一行指明这个文件属于哪个包，</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//每个 Go 应用程序都包含一个名为 main 的包。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span> <span class=\"comment\">//使用该包</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//fmt 包实现了格式化 IO（输入/输出）的函数。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"math\"</span>\t<span class=\"comment\">//分组导入语句</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    \t\t<span class=\"comment\">//注释和C语言是一样的</span></span><br><span class=\"line\">   fmt.Println(<span class=\"string\">\"Hello, World!\"</span>)<span class=\"comment\">//效果和Java的Println是一个效果，但句末不需分号</span></span><br><span class=\"line\">   \t\t\t\t\t\t\t<span class=\"comment\">//当同一行有多个语句时，用分号分隔，但不推荐</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Go的Hello World</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Group1 <span class=\"keyword\">int</span><span class=\"comment\">//定义形式</span></span><br><span class=\"line\"><span class=\"comment\">//那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）</span></span><br><span class=\"line\"><span class=\"comment\">//标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *\tGo中的基本类型：</span></span><br><span class=\"line\"><span class=\"comment\"> *\t数字类型(u)int8/16/32/64</span></span><br><span class=\"line\"><span class=\"comment\"> *\t浮点型float32/64,complex64/128</span></span><br><span class=\"line\"><span class=\"comment\"> *\t其他：byte uint8 的别名</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t rune int32 的别名, 表示一个 Unicode 码点 </span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t uint 32 or 64bit</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t int  same as uint</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t uintprt 无符号整型，用于存放一个指针</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span> <span class=\"keyword\">int</span><span class=\"comment\">//这种定义会出错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>\t<span class=\"comment\">//没问题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">int</span>\t<span class=\"comment\">//没问题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">int</span> =<span class=\"number\">2</span><span class=\"comment\">//没问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//没有明确初始值的变量声明会被赋予它们的零值。</span></span><br><span class=\"line\"><span class=\"comment\">//零值是：</span></span><br><span class=\"line\"><span class=\"comment\">//数值类型为 0 ，</span></span><br><span class=\"line\"><span class=\"comment\">//布尔类型为 false ，</span></span><br><span class=\"line\"><span class=\"comment\">//字符串为 \"\" （空字符串）。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//三种定义形式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span><span class=\"comment\">//交给Go自己判断</span></span><br><span class=\"line\">a := <span class=\"number\">2</span>\t<span class=\"comment\">//左侧变量不应被提前声明过</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//与Python类似的多变量声明</span></span><br><span class=\"line\"></span><br><span class=\"line\">a, b, c := <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一次声明多个不同类型的变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\ta <span class=\"keyword\">int</span></span><br><span class=\"line\">    b <span class=\"keyword\">bool</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> e, f = <span class=\"number\">123</span>, <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这种只能在函数体中出现</span></span><br><span class=\"line\">g, h := <span class=\"number\">123</span>, <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"comment\">//全局变量允许声明但不实用，局部变量声明不使用会报错</span></span><br><span class=\"line\"><span class=\"comment\">//因为函数外的每个语句都必须以关键字开始（ var 、 func 等等）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//常量定义格式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> identifier [<span class=\"keyword\">type</span>] = value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用作枚举</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tFirst = <span class=\"number\">0</span></span><br><span class=\"line\">    Second = <span class=\"number\">1</span></span><br><span class=\"line\">    Other = <span class=\"number\">2</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//特殊常量iota</span></span><br><span class=\"line\"><span class=\"comment\">//在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> (</span><br><span class=\"line\">            a = <span class=\"literal\">iota</span>   <span class=\"comment\">//0</span></span><br><span class=\"line\">            b          <span class=\"comment\">//1</span></span><br><span class=\"line\">            c          <span class=\"comment\">//2</span></span><br><span class=\"line\">            d = <span class=\"string\">\"ha\"</span>   <span class=\"comment\">//独立值，iota += 1</span></span><br><span class=\"line\">            e          <span class=\"comment\">//\"ha\"   iota += 1</span></span><br><span class=\"line\">            f = <span class=\"number\">100</span>    <span class=\"comment\">//iota +=1</span></span><br><span class=\"line\">            g          <span class=\"comment\">//100  iota +=1</span></span><br><span class=\"line\">            h = <span class=\"literal\">iota</span>   <span class=\"comment\">//7,恢复计数</span></span><br><span class=\"line\">            i          <span class=\"comment\">//8</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不同类型的数值没有隐式转换</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a <span class=\"keyword\">int8</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> b <span class=\"keyword\">int64</span></span><br><span class=\"line\">\ta = <span class=\"number\">123</span></span><br><span class=\"line\">\tb = <span class=\"number\">1234567890123456</span></span><br><span class=\"line\">\tfmt.Println(a^b, a+b, b-a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//λ go run math.go</span></span><br><span class=\"line\"><span class=\"comment\">//# command-line-arguments</span></span><br><span class=\"line\"><span class=\"comment\">//.\\math.go:10:15: invalid operation: a ^ b (mismatched types int8 and int64)</span></span><br><span class=\"line\"><span class=\"comment\">//.\\math.go:10:20: invalid operation: a + b (mismatched types int8 and int64)</span></span><br><span class=\"line\"><span class=\"comment\">//.\\math.go:10:25: invalid operation: b - a (mismatched types int64 and int8)</span></span><br></pre></td></tr></table></figure>\n<p>指针变量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a <span class=\"keyword\">int</span> = <span class=\"number\">4</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> ptr *<span class=\"keyword\">int</span></span><br><span class=\"line\">\tptr = &amp;a    <span class=\"comment\">/* 'ptr' 包含了 'a' 变量的地址 */</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"a 的值为  %d\\n\"</span>, a)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"*ptr 为 %d\\n\"</span>, *ptr)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"ptr的值为%p\"</span>,ptr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//a 的值为  4</span></span><br><span class=\"line\"><span class=\"comment\">//*ptr 为 4</span></span><br><span class=\"line\"><span class=\"comment\">//ptr的值为%p 0xc042060058</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>优先级</th>\n<th>运算符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>7</td>\n<td>^ !</td>\n</tr>\n<tr>\n<td>6</td>\n<td>* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td>\n</tr>\n<tr>\n<td>5</td>\n<td>+ - \\</td>\n<td>^</td>\n</tr>\n<tr>\n<td>4</td>\n<td>== != &lt; &lt;= &gt;= &gt;</td>\n</tr>\n<tr>\n<td>3</td>\n<td>&lt;-</td>\n</tr>\n<tr>\n<td>2</td>\n<td>&amp;&amp;</td>\n</tr>\n<tr>\n<td>1</td>\n<td>\\</td>\n<td>\\</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><p>if类似for，没有小括号，大括号必须，同时在条件表达式前执行语句可以声明变量，该语句声明的变量作用域仅在 if 之内。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"math\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(x, n, lim <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"%g &gt;= %g\\n\"</span>, v, lim)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 这里开始就不能使用 v 了</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lim</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(</span><br><span class=\"line\">\t\tpow(<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>),</span><br><span class=\"line\">\t\tpow(<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>switch同理</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"runtime\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Print(<span class=\"string\">\"Go runs on \"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> os := runtime.GOOS; os &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">\"darwin\"</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"OS X.\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">\"linux\"</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"Linux.\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">// freebsd, openbsd,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// plan9, windows...</span></span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"%s.\"</span>, os)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//switch的case从上到下顺次执行，匹配成功时停止</span></span><br></pre></td></tr></table></figure>\n<p>switch可以没有条件，用起来相当于if-then-else</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tt := time.Now()</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">12</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"Good morning!\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">17</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"Good afternoon.\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"Good evening.\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>defer 语句会将函数推迟到外层函数返回之后执行。</p>\n<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>\n<p>推迟的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>\n<p>更多关于 defer 语句的信息， 请阅读<a href=\"http://blog.go-zh.org/defer-panic-and-recover\" target=\"_blank\" rel=\"noopener\">此博文</a>。（感觉这个特性很有意思，但是是深坑的既视感）</p>\n<h3 id=\"神奇的select\"><a href=\"#神奇的select\" class=\"headerlink\" title=\"神奇的select\"></a>神奇的select</h3><p>之后补</p>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Go中只有for循环</span></span><br><span class=\"line\"><span class=\"comment\">//基本的 for 循环由三部分组成，它们用分号隔开：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化语句：在第一次迭代前执行</span></span><br><span class=\"line\"><span class=\"comment\">//条件表达式：在每次迭代前求值</span></span><br><span class=\"line\"><span class=\"comment\">//后置语句：在每次迭代的结尾执行</span></span><br><span class=\"line\"><span class=\"comment\">//初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一旦条件表达式的布尔值为 false，循环迭代就会终止。 注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面没有小括号，大括号 &#123; &#125; 则是必须的。</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tsum += i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(sum)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//55</span></span><br></pre></td></tr></table></figure>\n<p>初始化语句与后置语句是可选的部分</p>\n<p>省略循环条件表示无限循环</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数可以没有参数或接受多个参数，返回任意数量的返回值，如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(x <span class=\"keyword\">int</span>, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(add(<span class=\"number\">42</span>, <span class=\"number\">13</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta, b := swap(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>)</span><br><span class=\"line\">\tfmt.Println(a, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p>\n<p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p>\n<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX <span class=\"keyword\">int</span></span><br><span class=\"line\">\tY <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">\tv.X = <span class=\"number\">4</span></span><br><span class=\"line\">\tfmt.Println(v.X)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果有指向结构体的指针那么可以通过 (*p).X 来访问其字段 X 。 不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。</span></span><br><span class=\"line\"><span class=\"comment\">//结构体文法通过直接列出字段的值来新分配一个结构体。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span>\tv1 = Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;  <span class=\"comment\">// has type Vertex</span></span><br><span class=\"line\"><span class=\"comment\">//使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = Vertex&#123;X: <span class=\"number\">1</span>&#125;  <span class=\"comment\">// Y:0 is implicit</span></span><br><span class=\"line\"><span class=\"comment\">//特殊的前缀 &amp; 返回一个指向结构体的指针。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p  = &amp;Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// has type *Vertex</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p>\n<p>如：var a [10]int</p>\n<p>和Python类似的切片用法，但是只返回引用切片文法</p>\n<p>切片文法类似于没有长度的数组文法。</p>\n<p>这是一个数组文法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[3]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure>\n<p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tq := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">\tfmt.Println(q)</span><br><span class=\"line\"></span><br><span class=\"line\">\tr := []<span class=\"keyword\">bool</span>&#123;<span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">\tfmt.Println(r)</span><br><span class=\"line\"></span><br><span class=\"line\">\ts := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\ti <span class=\"keyword\">int</span></span><br><span class=\"line\">\t\tb <span class=\"keyword\">bool</span></span><br><span class=\"line\">\t&#125;&#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">2</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">3</span>, <span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">5</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">7</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">11</span>, <span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">13</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//[2 3 5 7 11 13]</span></span><br><span class=\"line\"><span class=\"comment\">//[true false true true false true]</span></span><br><span class=\"line\"><span class=\"comment\">//[&#123;2 true&#125; &#123;3 false&#125; &#123;5 true&#125; &#123;7 true&#125; &#123;11 false&#125; &#123;13 true&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong> 。</p>\n<p>切片的长度就是它所包含的元素个数。</p>\n<p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p>\n<p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p>\n<p>你可以通过重新切片来扩展一个切片，给它提供足够的容量。 试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Slice the slice to give it zero length.</span></span><br><span class=\"line\">\ts = s[:<span class=\"number\">0</span>]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Extend its length.</span></span><br><span class=\"line\">\ts = s[:<span class=\"number\">4</span>]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Drop its first two values.</span></span><br><span class=\"line\">\ts = s[<span class=\"number\">2</span>:]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSlice</span><span class=\"params\">(s []<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"len=%d cap=%d %v\\n\"</span>, <span class=\"built_in\">len</span>(s), <span class=\"built_in\">cap</span>(s), s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//len=6 cap=6 [2 3 5 7 11 13]</span></span><br><span class=\"line\"><span class=\"comment\">//len=0 cap=6 []</span></span><br><span class=\"line\"><span class=\"comment\">//len=4 cap=6 [2 3 5 7]</span></span><br><span class=\"line\"><span class=\"comment\">//len=2 cap=4 [5 7]</span></span><br></pre></td></tr></table></figure>\n<p>切片的零值是 <code>nil</code> 。</p>\n<p>nil 切片的长度和容量为 0 且没有底层数组</p>\n<p>切面可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p>\n<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := make([]int, 5)  // len(a)=5</span><br></pre></td></tr></table></figure>\n<p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b := make([]int, 0, 5) // len(b)=0, cap(b)=5</span><br><span class=\"line\"></span><br><span class=\"line\">b = b[:cap(b)] // len(b)=5, cap(b)=5</span><br><span class=\"line\">b = b[1:]      // len(b)=4, cap(b)=4</span><br></pre></td></tr></table></figure>\n<p>range for 每次迭代返回两个值，一个值为当前元素的下标，另一个值为该下标所对应元素的一份副本。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pow = []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">16</span>, <span class=\"number\">32</span>, <span class=\"number\">64</span>, <span class=\"number\">128</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"2**%d = %d\\n\"</span>, i, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2**0 = 1</span></span><br><span class=\"line\"><span class=\"comment\">//2**1 = 2</span></span><br><span class=\"line\"><span class=\"comment\">//2**2 = 4</span></span><br><span class=\"line\"><span class=\"comment\">//2**3 = 8</span></span><br><span class=\"line\"><span class=\"comment\">//2**4 = 16</span></span><br><span class=\"line\"><span class=\"comment\">//2**5 = 32</span></span><br><span class=\"line\"><span class=\"comment\">//2**6 = 64</span></span><br><span class=\"line\"><span class=\"comment\">//2**7 = 128</span></span><br></pre></td></tr></table></figure>\n<p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>\n<h1 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h1><p>就是map</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLat, Long <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Vertex&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"Bell Labs\"</span>: Vertex&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">40.68433</span>, <span class=\"number\">-74.39967</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"string\">\"Google\"</span>: Vertex&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">37.42202</span>, <span class=\"number\">-122.08408</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(m)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;]</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。</p>\n<p>例如，函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code> 变量上。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adder</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t\tsum += x</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sum</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tpos, neg := adder(), adder()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tfmt.Println(</span><br><span class=\"line\">\t\t\tpos(i),</span><br><span class=\"line\">\t\t\tneg(<span class=\"number\">-2</span>*i),</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//0 0</span></span><br><span class=\"line\"><span class=\"comment\">//1 -2</span></span><br><span class=\"line\"><span class=\"comment\">//3 -6</span></span><br><span class=\"line\"><span class=\"comment\">//6 -12</span></span><br><span class=\"line\"><span class=\"comment\">//10 -20</span></span><br><span class=\"line\"><span class=\"comment\">//15 -30</span></span><br><span class=\"line\"><span class=\"comment\">//21 -42</span></span><br><span class=\"line\"><span class=\"comment\">//28 -56</span></span><br><span class=\"line\"><span class=\"comment\">//36 -72</span></span><br><span class=\"line\"><span class=\"comment\">//45 -90</span></span><br></pre></td></tr></table></figure>\n<p>函数式编程啊！但是我不会啊！等我看完SICP再来！（滑稽XD</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"学习资料：\"><a href=\"#学习资料：\" class=\"headerlink\" title=\"学习资料：\"></a>学习资料：</h1><p>首推官方<a href=\"https://tour.go-zh.org/welcome/1\" target=\"_blank\" rel=\"noopener\">https://tour.go-zh.org/welcome/1</a><br>其次<a href=\"http://www.runoob.com/go/go-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/go/go-tutorial.html</a></p>\n<h1 id=\"瞎写的笔记\"><a href=\"#瞎写的笔记\" class=\"headerlink\" title=\"瞎写的笔记\"></a>瞎写的笔记</h1><h2 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main <span class=\"comment\">//必须在源文件中非注释的第一行指明这个文件属于哪个包，</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//每个 Go 应用程序都包含一个名为 main 的包。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span> <span class=\"comment\">//使用该包</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//fmt 包实现了格式化 IO（输入/输出）的函数。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">    <span class=\"string\">\"math\"</span>\t<span class=\"comment\">//分组导入语句</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    \t\t<span class=\"comment\">//注释和C语言是一样的</span></span><br><span class=\"line\">   fmt.Println(<span class=\"string\">\"Hello, World!\"</span>)<span class=\"comment\">//效果和Java的Println是一个效果，但句末不需分号</span></span><br><span class=\"line\">   \t\t\t\t\t\t\t<span class=\"comment\">//当同一行有多个语句时，用分号分隔，但不推荐</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Go的Hello World</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Group1 <span class=\"keyword\">int</span><span class=\"comment\">//定义形式</span></span><br><span class=\"line\"><span class=\"comment\">//那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）</span></span><br><span class=\"line\"><span class=\"comment\">//标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *\tGo中的基本类型：</span></span><br><span class=\"line\"><span class=\"comment\"> *\t数字类型(u)int8/16/32/64</span></span><br><span class=\"line\"><span class=\"comment\"> *\t浮点型float32/64,complex64/128</span></span><br><span class=\"line\"><span class=\"comment\"> *\t其他：byte uint8 的别名</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t rune int32 的别名, 表示一个 Unicode 码点 </span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t uint 32 or 64bit</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t int  same as uint</span></span><br><span class=\"line\"><span class=\"comment\"> *\t\t uintprt 无符号整型，用于存放一个指针</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span> <span class=\"keyword\">int</span><span class=\"comment\">//这种定义会出错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>\t<span class=\"comment\">//没问题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">int</span>\t<span class=\"comment\">//没问题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">int</span> =<span class=\"number\">2</span><span class=\"comment\">//没问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//没有明确初始值的变量声明会被赋予它们的零值。</span></span><br><span class=\"line\"><span class=\"comment\">//零值是：</span></span><br><span class=\"line\"><span class=\"comment\">//数值类型为 0 ，</span></span><br><span class=\"line\"><span class=\"comment\">//布尔类型为 false ，</span></span><br><span class=\"line\"><span class=\"comment\">//字符串为 \"\" （空字符串）。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//三种定义形式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span><span class=\"comment\">//交给Go自己判断</span></span><br><span class=\"line\">a := <span class=\"number\">2</span>\t<span class=\"comment\">//左侧变量不应被提前声明过</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//与Python类似的多变量声明</span></span><br><span class=\"line\"></span><br><span class=\"line\">a, b, c := <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一次声明多个不同类型的变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\ta <span class=\"keyword\">int</span></span><br><span class=\"line\">    b <span class=\"keyword\">bool</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> e, f = <span class=\"number\">123</span>, <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这种只能在函数体中出现</span></span><br><span class=\"line\">g, h := <span class=\"number\">123</span>, <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"><span class=\"comment\">//全局变量允许声明但不实用，局部变量声明不使用会报错</span></span><br><span class=\"line\"><span class=\"comment\">//因为函数外的每个语句都必须以关键字开始（ var 、 func 等等）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//常量定义格式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> identifier [<span class=\"keyword\">type</span>] = value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用作枚举</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tFirst = <span class=\"number\">0</span></span><br><span class=\"line\">    Second = <span class=\"number\">1</span></span><br><span class=\"line\">    Other = <span class=\"number\">2</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//特殊常量iota</span></span><br><span class=\"line\"><span class=\"comment\">//在每一个const关键字出现时，被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字会自动增加1。</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> (</span><br><span class=\"line\">            a = <span class=\"literal\">iota</span>   <span class=\"comment\">//0</span></span><br><span class=\"line\">            b          <span class=\"comment\">//1</span></span><br><span class=\"line\">            c          <span class=\"comment\">//2</span></span><br><span class=\"line\">            d = <span class=\"string\">\"ha\"</span>   <span class=\"comment\">//独立值，iota += 1</span></span><br><span class=\"line\">            e          <span class=\"comment\">//\"ha\"   iota += 1</span></span><br><span class=\"line\">            f = <span class=\"number\">100</span>    <span class=\"comment\">//iota +=1</span></span><br><span class=\"line\">            g          <span class=\"comment\">//100  iota +=1</span></span><br><span class=\"line\">            h = <span class=\"literal\">iota</span>   <span class=\"comment\">//7,恢复计数</span></span><br><span class=\"line\">            i          <span class=\"comment\">//8</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不同类型的数值没有隐式转换</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a <span class=\"keyword\">int8</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> b <span class=\"keyword\">int64</span></span><br><span class=\"line\">\ta = <span class=\"number\">123</span></span><br><span class=\"line\">\tb = <span class=\"number\">1234567890123456</span></span><br><span class=\"line\">\tfmt.Println(a^b, a+b, b-a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//λ go run math.go</span></span><br><span class=\"line\"><span class=\"comment\">//# command-line-arguments</span></span><br><span class=\"line\"><span class=\"comment\">//.\\math.go:10:15: invalid operation: a ^ b (mismatched types int8 and int64)</span></span><br><span class=\"line\"><span class=\"comment\">//.\\math.go:10:20: invalid operation: a + b (mismatched types int8 and int64)</span></span><br><span class=\"line\"><span class=\"comment\">//.\\math.go:10:25: invalid operation: b - a (mismatched types int64 and int8)</span></span><br></pre></td></tr></table></figure>\n<p>指针变量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a <span class=\"keyword\">int</span> = <span class=\"number\">4</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> ptr *<span class=\"keyword\">int</span></span><br><span class=\"line\">\tptr = &amp;a    <span class=\"comment\">/* 'ptr' 包含了 'a' 变量的地址 */</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"a 的值为  %d\\n\"</span>, a)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"*ptr 为 %d\\n\"</span>, *ptr)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"ptr的值为%p\"</span>,ptr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//a 的值为  4</span></span><br><span class=\"line\"><span class=\"comment\">//*ptr 为 4</span></span><br><span class=\"line\"><span class=\"comment\">//ptr的值为%p 0xc042060058</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>优先级</th>\n<th>运算符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>7</td>\n<td>^ !</td>\n</tr>\n<tr>\n<td>6</td>\n<td>* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td>\n</tr>\n<tr>\n<td>5</td>\n<td>+ - \\</td>\n<td>^</td>\n</tr>\n<tr>\n<td>4</td>\n<td>== != &lt; &lt;= &gt;= &gt;</td>\n</tr>\n<tr>\n<td>3</td>\n<td>&lt;-</td>\n</tr>\n<tr>\n<td>2</td>\n<td>&amp;&amp;</td>\n</tr>\n<tr>\n<td>1</td>\n<td>\\</td>\n<td>\\</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><p>if类似for，没有小括号，大括号必须，同时在条件表达式前执行语句可以声明变量，该语句声明的变量作用域仅在 if 之内。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"math\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(x, n, lim <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"%g &gt;= %g\\n\"</span>, v, lim)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 这里开始就不能使用 v 了</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lim</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(</span><br><span class=\"line\">\t\tpow(<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>),</span><br><span class=\"line\">\t\tpow(<span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">20</span>),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>switch同理</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"runtime\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Print(<span class=\"string\">\"Go runs on \"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> os := runtime.GOOS; os &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">\"darwin\"</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"OS X.\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"string\">\"linux\"</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"Linux.\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"comment\">// freebsd, openbsd,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// plan9, windows...</span></span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"%s.\"</span>, os)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//switch的case从上到下顺次执行，匹配成功时停止</span></span><br></pre></td></tr></table></figure>\n<p>switch可以没有条件，用起来相当于if-then-else</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tt := time.Now()</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">12</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"Good morning!\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">17</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"Good afternoon.\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">\"Good evening.\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>defer 语句会将函数推迟到外层函数返回之后执行。</p>\n<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>\n<p>推迟的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>\n<p>更多关于 defer 语句的信息， 请阅读<a href=\"http://blog.go-zh.org/defer-panic-and-recover\" target=\"_blank\" rel=\"noopener\">此博文</a>。（感觉这个特性很有意思，但是是深坑的既视感）</p>\n<h3 id=\"神奇的select\"><a href=\"#神奇的select\" class=\"headerlink\" title=\"神奇的select\"></a>神奇的select</h3><p>之后补</p>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Go中只有for循环</span></span><br><span class=\"line\"><span class=\"comment\">//基本的 for 循环由三部分组成，它们用分号隔开：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化语句：在第一次迭代前执行</span></span><br><span class=\"line\"><span class=\"comment\">//条件表达式：在每次迭代前求值</span></span><br><span class=\"line\"><span class=\"comment\">//后置语句：在每次迭代的结尾执行</span></span><br><span class=\"line\"><span class=\"comment\">//初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一旦条件表达式的布尔值为 false，循环迭代就会终止。 注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面没有小括号，大括号 &#123; &#125; 则是必须的。</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tsum += i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(sum)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//55</span></span><br></pre></td></tr></table></figure>\n<p>初始化语句与后置语句是可选的部分</p>\n<p>省略循环条件表示无限循环</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数可以没有参数或接受多个参数，返回任意数量的返回值，如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(x <span class=\"keyword\">int</span>, y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(add(<span class=\"number\">42</span>, <span class=\"number\">13</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta, b := swap(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>)</span><br><span class=\"line\">\tfmt.Println(a, b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p>\n<p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p>\n<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX <span class=\"keyword\">int</span></span><br><span class=\"line\">\tY <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">\tv.X = <span class=\"number\">4</span></span><br><span class=\"line\">\tfmt.Println(v.X)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果有指向结构体的指针那么可以通过 (*p).X 来访问其字段 X 。 不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。</span></span><br><span class=\"line\"><span class=\"comment\">//结构体文法通过直接列出字段的值来新分配一个结构体。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span>\tv1 = Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;  <span class=\"comment\">// has type Vertex</span></span><br><span class=\"line\"><span class=\"comment\">//使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v2 = Vertex&#123;X: <span class=\"number\">1</span>&#125;  <span class=\"comment\">// Y:0 is implicit</span></span><br><span class=\"line\"><span class=\"comment\">//特殊的前缀 &amp; 返回一个指向结构体的指针。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p  = &amp;Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// has type *Vertex</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p>\n<p>如：var a [10]int</p>\n<p>和Python类似的切片用法，但是只返回引用切片文法</p>\n<p>切片文法类似于没有长度的数组文法。</p>\n<p>这是一个数组文法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[3]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure>\n<p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tq := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">\tfmt.Println(q)</span><br><span class=\"line\"></span><br><span class=\"line\">\tr := []<span class=\"keyword\">bool</span>&#123;<span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">\tfmt.Println(r)</span><br><span class=\"line\"></span><br><span class=\"line\">\ts := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\ti <span class=\"keyword\">int</span></span><br><span class=\"line\">\t\tb <span class=\"keyword\">bool</span></span><br><span class=\"line\">\t&#125;&#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">2</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">3</span>, <span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">5</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">7</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">11</span>, <span class=\"literal\">false</span>&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">13</span>, <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//[2 3 5 7 11 13]</span></span><br><span class=\"line\"><span class=\"comment\">//[true false true true false true]</span></span><br><span class=\"line\"><span class=\"comment\">//[&#123;2 true&#125; &#123;3 false&#125; &#123;5 true&#125; &#123;7 true&#125; &#123;11 false&#125; &#123;13 true&#125;]</span></span><br></pre></td></tr></table></figure>\n<p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong> 。</p>\n<p>切片的长度就是它所包含的元素个数。</p>\n<p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p>\n<p>切片 <code>s</code> 的长度和容量可通过表达式 <code>len(s)</code> 和 <code>cap(s)</code> 来获取。</p>\n<p>你可以通过重新切片来扩展一个切片，给它提供足够的容量。 试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Slice the slice to give it zero length.</span></span><br><span class=\"line\">\ts = s[:<span class=\"number\">0</span>]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Extend its length.</span></span><br><span class=\"line\">\ts = s[:<span class=\"number\">4</span>]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Drop its first two values.</span></span><br><span class=\"line\">\ts = s[<span class=\"number\">2</span>:]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSlice</span><span class=\"params\">(s []<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"len=%d cap=%d %v\\n\"</span>, <span class=\"built_in\">len</span>(s), <span class=\"built_in\">cap</span>(s), s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//len=6 cap=6 [2 3 5 7 11 13]</span></span><br><span class=\"line\"><span class=\"comment\">//len=0 cap=6 []</span></span><br><span class=\"line\"><span class=\"comment\">//len=4 cap=6 [2 3 5 7]</span></span><br><span class=\"line\"><span class=\"comment\">//len=2 cap=4 [5 7]</span></span><br></pre></td></tr></table></figure>\n<p>切片的零值是 <code>nil</code> 。</p>\n<p>nil 切片的长度和容量为 0 且没有底层数组</p>\n<p>切面可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p>\n<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := make([]int, 5)  // len(a)=5</span><br></pre></td></tr></table></figure>\n<p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b := make([]int, 0, 5) // len(b)=0, cap(b)=5</span><br><span class=\"line\"></span><br><span class=\"line\">b = b[:cap(b)] // len(b)=5, cap(b)=5</span><br><span class=\"line\">b = b[1:]      // len(b)=4, cap(b)=4</span><br></pre></td></tr></table></figure>\n<p>range for 每次迭代返回两个值，一个值为当前元素的下标，另一个值为该下标所对应元素的一份副本。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pow = []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">16</span>, <span class=\"number\">32</span>, <span class=\"number\">64</span>, <span class=\"number\">128</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">\"2**%d = %d\\n\"</span>, i, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2**0 = 1</span></span><br><span class=\"line\"><span class=\"comment\">//2**1 = 2</span></span><br><span class=\"line\"><span class=\"comment\">//2**2 = 4</span></span><br><span class=\"line\"><span class=\"comment\">//2**3 = 8</span></span><br><span class=\"line\"><span class=\"comment\">//2**4 = 16</span></span><br><span class=\"line\"><span class=\"comment\">//2**5 = 32</span></span><br><span class=\"line\"><span class=\"comment\">//2**6 = 64</span></span><br><span class=\"line\"><span class=\"comment\">//2**7 = 128</span></span><br></pre></td></tr></table></figure>\n<p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>\n<h1 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h1><p>就是map</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLat, Long <span class=\"keyword\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Vertex&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"Bell Labs\"</span>: Vertex&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">40.68433</span>, <span class=\"number\">-74.39967</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t<span class=\"string\">\"Google\"</span>: Vertex&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">37.42202</span>, <span class=\"number\">-122.08408</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(m)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//map[Bell Labs:&#123;40.68433 -74.39967&#125; Google:&#123;37.42202 -122.08408&#125;]</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。</p>\n<p>例如，函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code> 变量上。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adder</span><span class=\"params\">()</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t\tsum += x</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sum</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tpos, neg := adder(), adder()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tfmt.Println(</span><br><span class=\"line\">\t\t\tpos(i),</span><br><span class=\"line\">\t\t\tneg(<span class=\"number\">-2</span>*i),</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//0 0</span></span><br><span class=\"line\"><span class=\"comment\">//1 -2</span></span><br><span class=\"line\"><span class=\"comment\">//3 -6</span></span><br><span class=\"line\"><span class=\"comment\">//6 -12</span></span><br><span class=\"line\"><span class=\"comment\">//10 -20</span></span><br><span class=\"line\"><span class=\"comment\">//15 -30</span></span><br><span class=\"line\"><span class=\"comment\">//21 -42</span></span><br><span class=\"line\"><span class=\"comment\">//28 -56</span></span><br><span class=\"line\"><span class=\"comment\">//36 -72</span></span><br><span class=\"line\"><span class=\"comment\">//45 -90</span></span><br></pre></td></tr></table></figure>\n<p>函数式编程啊！但是我不会啊！等我看完SICP再来！（滑稽XD</p>\n"},{"title":"区块链学习笔记（一）","connments":true,"date":"2018-01-20T08:31:04.000Z","comment":true,"summary":"这里也就可以发现一个区块链提出的很重要的目标：解决信任问题。在目前的网络体系中，第三方机构的存在使信任问题不可避免。而在另一方面，区块链天生具有不可逆与不可篡改的特性同样是我们经常需要追求的特性，尤其是诸如贸易、签署合同、投票、通信等场景。","desc":"学习区块链过程里做的笔记","_content":"\n## 学习资料：\n\n-    [[Bitcoin: A Peer-to-Peer Electronic Cash System](https://bitcoin.org/bitcoin.pdf)]\n-    [比特币白皮书 个人翻译+注解](https://zhuanlan.zhihu.com/p/25039679)\n\n## 学习笔记：\n\n**采用原文-自己理解的方式记录，原文部分可能经过拼装。**\n\n-    传统的数字贸易为了防止双重支付(double-spending)，需要引入一个双方都新人的第三方来解决。因为这种与生俱来的基于信任的模型的缺陷，完全的不可逆交易不是真正可能的，因为金融机构不能避免纠纷协调处理。协调调解的成本增加了交易的成本，限制了最小的实际交易规模并且切断了小型临时交易的可能。并且在对不可逆服务进行不可逆付款的弱项方面存在更大的成本。因为存在撤销的可能性，对信任的需要就被分散了。商户需要对他们的客户提高警惕，所以收集他们比起需要的更多信息。一定比率的欺诈被视为是可能的。这种成本和不确定的交易是可被避免的当一个人是通过现实现金交易的方式，但是没有一个存在的机制来确保交易是通过一个没有可信方的通信通道进行支付的。\n\n这里也就可以发现一个区块链提出的很重要的目标：解决信任问题。在目前的网络体系中，第三方机构的存在使信任问题不可避免。而在另一方面，区块链天生具有不可逆与不可篡改的特性同样是我们经常需要追求的特性，尤其是诸如贸易、签署合同、投票、通信等场景。\n\n-    现在需要的就是一个基于密码学加密证明来替代信任的电子支付系统，允许任何两方能够在不需要一个可信的第三方的场景下直接交易。计算上保证的不可逆交易将会保护卖方免受欺诈，并且常规的托管机制可以很容易的被实现来保护买方。在这篇论文里，我们提出一种方案来解决双重支付问题，使用一种P2P分布式的时间戳服务来生成交易的时间顺序的计算证明。只要诚实节点比合作攻击的节点控制了更多的CPU计算力，那么整个系统就是安全的。\n\n这里指出，实际上信任问题是由原来的机构或者其他的信任转移到了“密码学加密”的数学体系上，变为了是否相信数学是可靠的问题。但是后一句的语言表达上实际上暗示了区块链这个体系实际上是支付方比接收方更具备一点优势，不是绝对平等的地位，所以接收方需要担心支付方的攻击(二次支付)。最后说明，区块链解决两重支付，基础的拓扑结构是P2P，时间戳是确认交易顺序的方式。\n\n-    我们定义一枚电子硬币为一些数字签名形成的链。每一个所有者通过对之前的交易和下一个所有者的公钥的一个散列值进行数字签名并将其附在硬币的末尾来把硬币交易给下一个人。一个接受者可以通过确认签名来确认这条所有权链(chain of ownership)。\n\n     {% asset_img snipaste20180118_002602.jpg 区块链简略示意图 %}\n\n论文中的电子硬币实际上是一条链\n\n-    这个过程的问题是收款人不能验证付款人中(one of the owners)没有人双重支付货币。一个常用的解决方案是引入一个可信的中央认证，或铸币厂(mint)，来对每一笔交易检查是否被双重支付。在每一笔交易后，这个货币必须被返回到铸币场来发行一枚新的硬币，并且只有货币被直接的从可信的铸币厂发行才能保证不被双重支付。这个解决方案的问题是全部货币(money)的命运都依靠在这个公司运作的铸币厂上，每一笔交易都必须通过他们，就像一个银行一样。\n\n     我们提出的方案以一个时间戳服务器开始。一个时间戳服务器的工作就是把一组等待加上时间戳的物品(item)形成的区块(block)进行散列并将其广播。时间戳证明在那个时间必然存在，显然的，为了获得那个散列值。每个时间戳包括之前的时间戳在自己的散列值中(Each timestamp includes the previous timestamp in its hash)，形成了一条链，随着每个新的时间戳都加强了这个之前所有的时间戳。{% asset_img snipaste20180118_004710.jpg test %}\n\n-    为了在点对点的基础上实现一个分布式的时间戳服务器，我们需要使用类似于Adam Back的[Hashcash](http://www.hashcash.org/papers/hashcash.pdf)的工作量证明(PoW, proof-of-work)，而不是报纸或者世界新闻网络组。工作量证明机制引入在散列的时候对一个  值的扫描(scan)，例如在SHA-256下，这个散列从一串0开始。需要的平均工作与所需0数成指数关系，并且可以通过执行简单的(或者单个的？)(single)散列函数来被验证。\n\n-    对于我们的时间戳网络，我们通过在后面增加一个随机串(nonce)来落实PoW，直到添加的随机串使得区块的散列值达到了所需的0数。一旦CPU效率被花费来满足工作量证明，除非重做相应的工作这个区块不能再被改变。随着之后有新区快链接上，改变单个区块将需要重做所有之后区块所对应的工作。（下图比上图更贴近区块链中区块的真实结构）\n\n     {% asset_img snipaste20180118_013210.jpg test %}\n\n-    工作量证明同时解决了多数决策中决定代表的问题。如果大多数人只根据一人一ip进行投票(one-IP-one_vote)，这样会被任何能够分配很多ip的人破坏。工作量证明本质上是一CPU一票(one-CPU-one-vote)。主要的(大多数)的决定是由最长的链所代表，最长链拥有最大的工作量花费在其中。如果一个大多数CPU算力都被诚实节点所控制，那么最诚实的链就会增长的最快且超过其他任何计算链。想要改变一个过去的区块，攻击者需要重做这个区块和所有在这个块后的区块的工作量证明，之后还要追赶上并超过现在所有诚实节点的工作。我们之后会说明，一个慢速的攻击者能够追赶上的可能性将会随着后续的块被添加指数级的减少。\n\n## 画个图总结一下\n\n{% asset_img 新文档_2018-01-18_1.jpg test %}","source":"_posts/区块链学习笔记（一）.md","raw":"---\ntitle: 区块链学习笔记（一）\nconnments: true\ndate: 2018-01-20 16:31:04\ntags: blockchain\ncategories: Notes\ncomment: true\nsummary: 这里也就可以发现一个区块链提出的很重要的目标：解决信任问题。在目前的网络体系中，第三方机构的存在使信任问题不可避免。而在另一方面，区块链天生具有不可逆与不可篡改的特性同样是我们经常需要追求的特性，尤其是诸如贸易、签署合同、投票、通信等场景。\ndesc: 学习区块链过程里做的笔记\n\n---\n\n## 学习资料：\n\n-    [[Bitcoin: A Peer-to-Peer Electronic Cash System](https://bitcoin.org/bitcoin.pdf)]\n-    [比特币白皮书 个人翻译+注解](https://zhuanlan.zhihu.com/p/25039679)\n\n## 学习笔记：\n\n**采用原文-自己理解的方式记录，原文部分可能经过拼装。**\n\n-    传统的数字贸易为了防止双重支付(double-spending)，需要引入一个双方都新人的第三方来解决。因为这种与生俱来的基于信任的模型的缺陷，完全的不可逆交易不是真正可能的，因为金融机构不能避免纠纷协调处理。协调调解的成本增加了交易的成本，限制了最小的实际交易规模并且切断了小型临时交易的可能。并且在对不可逆服务进行不可逆付款的弱项方面存在更大的成本。因为存在撤销的可能性，对信任的需要就被分散了。商户需要对他们的客户提高警惕，所以收集他们比起需要的更多信息。一定比率的欺诈被视为是可能的。这种成本和不确定的交易是可被避免的当一个人是通过现实现金交易的方式，但是没有一个存在的机制来确保交易是通过一个没有可信方的通信通道进行支付的。\n\n这里也就可以发现一个区块链提出的很重要的目标：解决信任问题。在目前的网络体系中，第三方机构的存在使信任问题不可避免。而在另一方面，区块链天生具有不可逆与不可篡改的特性同样是我们经常需要追求的特性，尤其是诸如贸易、签署合同、投票、通信等场景。\n\n-    现在需要的就是一个基于密码学加密证明来替代信任的电子支付系统，允许任何两方能够在不需要一个可信的第三方的场景下直接交易。计算上保证的不可逆交易将会保护卖方免受欺诈，并且常规的托管机制可以很容易的被实现来保护买方。在这篇论文里，我们提出一种方案来解决双重支付问题，使用一种P2P分布式的时间戳服务来生成交易的时间顺序的计算证明。只要诚实节点比合作攻击的节点控制了更多的CPU计算力，那么整个系统就是安全的。\n\n这里指出，实际上信任问题是由原来的机构或者其他的信任转移到了“密码学加密”的数学体系上，变为了是否相信数学是可靠的问题。但是后一句的语言表达上实际上暗示了区块链这个体系实际上是支付方比接收方更具备一点优势，不是绝对平等的地位，所以接收方需要担心支付方的攻击(二次支付)。最后说明，区块链解决两重支付，基础的拓扑结构是P2P，时间戳是确认交易顺序的方式。\n\n-    我们定义一枚电子硬币为一些数字签名形成的链。每一个所有者通过对之前的交易和下一个所有者的公钥的一个散列值进行数字签名并将其附在硬币的末尾来把硬币交易给下一个人。一个接受者可以通过确认签名来确认这条所有权链(chain of ownership)。\n\n     {% asset_img snipaste20180118_002602.jpg 区块链简略示意图 %}\n\n论文中的电子硬币实际上是一条链\n\n-    这个过程的问题是收款人不能验证付款人中(one of the owners)没有人双重支付货币。一个常用的解决方案是引入一个可信的中央认证，或铸币厂(mint)，来对每一笔交易检查是否被双重支付。在每一笔交易后，这个货币必须被返回到铸币场来发行一枚新的硬币，并且只有货币被直接的从可信的铸币厂发行才能保证不被双重支付。这个解决方案的问题是全部货币(money)的命运都依靠在这个公司运作的铸币厂上，每一笔交易都必须通过他们，就像一个银行一样。\n\n     我们提出的方案以一个时间戳服务器开始。一个时间戳服务器的工作就是把一组等待加上时间戳的物品(item)形成的区块(block)进行散列并将其广播。时间戳证明在那个时间必然存在，显然的，为了获得那个散列值。每个时间戳包括之前的时间戳在自己的散列值中(Each timestamp includes the previous timestamp in its hash)，形成了一条链，随着每个新的时间戳都加强了这个之前所有的时间戳。{% asset_img snipaste20180118_004710.jpg test %}\n\n-    为了在点对点的基础上实现一个分布式的时间戳服务器，我们需要使用类似于Adam Back的[Hashcash](http://www.hashcash.org/papers/hashcash.pdf)的工作量证明(PoW, proof-of-work)，而不是报纸或者世界新闻网络组。工作量证明机制引入在散列的时候对一个  值的扫描(scan)，例如在SHA-256下，这个散列从一串0开始。需要的平均工作与所需0数成指数关系，并且可以通过执行简单的(或者单个的？)(single)散列函数来被验证。\n\n-    对于我们的时间戳网络，我们通过在后面增加一个随机串(nonce)来落实PoW，直到添加的随机串使得区块的散列值达到了所需的0数。一旦CPU效率被花费来满足工作量证明，除非重做相应的工作这个区块不能再被改变。随着之后有新区快链接上，改变单个区块将需要重做所有之后区块所对应的工作。（下图比上图更贴近区块链中区块的真实结构）\n\n     {% asset_img snipaste20180118_013210.jpg test %}\n\n-    工作量证明同时解决了多数决策中决定代表的问题。如果大多数人只根据一人一ip进行投票(one-IP-one_vote)，这样会被任何能够分配很多ip的人破坏。工作量证明本质上是一CPU一票(one-CPU-one-vote)。主要的(大多数)的决定是由最长的链所代表，最长链拥有最大的工作量花费在其中。如果一个大多数CPU算力都被诚实节点所控制，那么最诚实的链就会增长的最快且超过其他任何计算链。想要改变一个过去的区块，攻击者需要重做这个区块和所有在这个块后的区块的工作量证明，之后还要追赶上并超过现在所有诚实节点的工作。我们之后会说明，一个慢速的攻击者能够追赶上的可能性将会随着后续的块被添加指数级的减少。\n\n## 画个图总结一下\n\n{% asset_img 新文档_2018-01-18_1.jpg test %}","slug":"区块链学习笔记（一）","published":1,"updated":"2018-03-15T14:37:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgqnsczk0005dkudw3a4h194","content":"<h2 id=\"学习资料：\"><a href=\"#学习资料：\" class=\"headerlink\" title=\"学习资料：\"></a>学习资料：</h2><ul>\n<li>[<a href=\"https://bitcoin.org/bitcoin.pdf\" target=\"_blank\" rel=\"noopener\">Bitcoin: A Peer-to-Peer Electronic Cash System</a>]</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25039679\" target=\"_blank\" rel=\"noopener\">比特币白皮书 个人翻译+注解</a></li>\n</ul>\n<h2 id=\"学习笔记：\"><a href=\"#学习笔记：\" class=\"headerlink\" title=\"学习笔记：\"></a>学习笔记：</h2><p><strong>采用原文-自己理解的方式记录，原文部分可能经过拼装。</strong></p>\n<ul>\n<li>传统的数字贸易为了防止双重支付(double-spending)，需要引入一个双方都新人的第三方来解决。因为这种与生俱来的基于信任的模型的缺陷，完全的不可逆交易不是真正可能的，因为金融机构不能避免纠纷协调处理。协调调解的成本增加了交易的成本，限制了最小的实际交易规模并且切断了小型临时交易的可能。并且在对不可逆服务进行不可逆付款的弱项方面存在更大的成本。因为存在撤销的可能性，对信任的需要就被分散了。商户需要对他们的客户提高警惕，所以收集他们比起需要的更多信息。一定比率的欺诈被视为是可能的。这种成本和不确定的交易是可被避免的当一个人是通过现实现金交易的方式，但是没有一个存在的机制来确保交易是通过一个没有可信方的通信通道进行支付的。</li>\n</ul>\n<p>这里也就可以发现一个区块链提出的很重要的目标：解决信任问题。在目前的网络体系中，第三方机构的存在使信任问题不可避免。而在另一方面，区块链天生具有不可逆与不可篡改的特性同样是我们经常需要追求的特性，尤其是诸如贸易、签署合同、投票、通信等场景。</p>\n<ul>\n<li>现在需要的就是一个基于密码学加密证明来替代信任的电子支付系统，允许任何两方能够在不需要一个可信的第三方的场景下直接交易。计算上保证的不可逆交易将会保护卖方免受欺诈，并且常规的托管机制可以很容易的被实现来保护买方。在这篇论文里，我们提出一种方案来解决双重支付问题，使用一种P2P分布式的时间戳服务来生成交易的时间顺序的计算证明。只要诚实节点比合作攻击的节点控制了更多的CPU计算力，那么整个系统就是安全的。</li>\n</ul>\n<p>这里指出，实际上信任问题是由原来的机构或者其他的信任转移到了“密码学加密”的数学体系上，变为了是否相信数学是可靠的问题。但是后一句的语言表达上实际上暗示了区块链这个体系实际上是支付方比接收方更具备一点优势，不是绝对平等的地位，所以接收方需要担心支付方的攻击(二次支付)。最后说明，区块链解决两重支付，基础的拓扑结构是P2P，时间戳是确认交易顺序的方式。</p>\n<ul>\n<li><p>我们定义一枚电子硬币为一些数字签名形成的链。每一个所有者通过对之前的交易和下一个所有者的公钥的一个散列值进行数字签名并将其附在硬币的末尾来把硬币交易给下一个人。一个接受者可以通过确认签名来确认这条所有权链(chain of ownership)。</p>\n<img src=\"/2018/01/20/区块链学习笔记（一）/snipaste20180118_002602.jpg\" title=\"区块链简略示意图\">\n</li>\n</ul>\n<p>论文中的电子硬币实际上是一条链</p>\n<ul>\n<li><p>这个过程的问题是收款人不能验证付款人中(one of the owners)没有人双重支付货币。一个常用的解决方案是引入一个可信的中央认证，或铸币厂(mint)，来对每一笔交易检查是否被双重支付。在每一笔交易后，这个货币必须被返回到铸币场来发行一枚新的硬币，并且只有货币被直接的从可信的铸币厂发行才能保证不被双重支付。这个解决方案的问题是全部货币(money)的命运都依靠在这个公司运作的铸币厂上，每一笔交易都必须通过他们，就像一个银行一样。</p>\n<p>我们提出的方案以一个时间戳服务器开始。一个时间戳服务器的工作就是把一组等待加上时间戳的物品(item)形成的区块(block)进行散列并将其广播。时间戳证明在那个时间必然存在，显然的，为了获得那个散列值。每个时间戳包括之前的时间戳在自己的散列值中(Each timestamp includes the previous timestamp in its hash)，形成了一条链，随着每个新的时间戳都加强了这个之前所有的时间戳。<img src=\"/2018/01/20/区块链学习笔记（一）/snipaste20180118_004710.jpg\" title=\"test\"></p>\n</li>\n<li><p>为了在点对点的基础上实现一个分布式的时间戳服务器，我们需要使用类似于Adam Back的<a href=\"http://www.hashcash.org/papers/hashcash.pdf\" target=\"_blank\" rel=\"noopener\">Hashcash</a>的工作量证明(PoW, proof-of-work)，而不是报纸或者世界新闻网络组。工作量证明机制引入在散列的时候对一个  值的扫描(scan)，例如在SHA-256下，这个散列从一串0开始。需要的平均工作与所需0数成指数关系，并且可以通过执行简单的(或者单个的？)(single)散列函数来被验证。</p>\n</li>\n<li><p>对于我们的时间戳网络，我们通过在后面增加一个随机串(nonce)来落实PoW，直到添加的随机串使得区块的散列值达到了所需的0数。一旦CPU效率被花费来满足工作量证明，除非重做相应的工作这个区块不能再被改变。随着之后有新区快链接上，改变单个区块将需要重做所有之后区块所对应的工作。（下图比上图更贴近区块链中区块的真实结构）</p>\n<img src=\"/2018/01/20/区块链学习笔记（一）/snipaste20180118_013210.jpg\" title=\"test\">\n</li>\n<li><p>工作量证明同时解决了多数决策中决定代表的问题。如果大多数人只根据一人一ip进行投票(one-IP-one_vote)，这样会被任何能够分配很多ip的人破坏。工作量证明本质上是一CPU一票(one-CPU-one-vote)。主要的(大多数)的决定是由最长的链所代表，最长链拥有最大的工作量花费在其中。如果一个大多数CPU算力都被诚实节点所控制，那么最诚实的链就会增长的最快且超过其他任何计算链。想要改变一个过去的区块，攻击者需要重做这个区块和所有在这个块后的区块的工作量证明，之后还要追赶上并超过现在所有诚实节点的工作。我们之后会说明，一个慢速的攻击者能够追赶上的可能性将会随着后续的块被添加指数级的减少。</p>\n</li>\n</ul>\n<h2 id=\"画个图总结一下\"><a href=\"#画个图总结一下\" class=\"headerlink\" title=\"画个图总结一下\"></a>画个图总结一下</h2><img src=\"/2018/01/20/区块链学习笔记（一）/新文档_2018-01-18_1.jpg\" title=\"test\">","site":{"data":{}},"excerpt":"","more":"<h2 id=\"学习资料：\"><a href=\"#学习资料：\" class=\"headerlink\" title=\"学习资料：\"></a>学习资料：</h2><ul>\n<li>[<a href=\"https://bitcoin.org/bitcoin.pdf\" target=\"_blank\" rel=\"noopener\">Bitcoin: A Peer-to-Peer Electronic Cash System</a>]</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25039679\" target=\"_blank\" rel=\"noopener\">比特币白皮书 个人翻译+注解</a></li>\n</ul>\n<h2 id=\"学习笔记：\"><a href=\"#学习笔记：\" class=\"headerlink\" title=\"学习笔记：\"></a>学习笔记：</h2><p><strong>采用原文-自己理解的方式记录，原文部分可能经过拼装。</strong></p>\n<ul>\n<li>传统的数字贸易为了防止双重支付(double-spending)，需要引入一个双方都新人的第三方来解决。因为这种与生俱来的基于信任的模型的缺陷，完全的不可逆交易不是真正可能的，因为金融机构不能避免纠纷协调处理。协调调解的成本增加了交易的成本，限制了最小的实际交易规模并且切断了小型临时交易的可能。并且在对不可逆服务进行不可逆付款的弱项方面存在更大的成本。因为存在撤销的可能性，对信任的需要就被分散了。商户需要对他们的客户提高警惕，所以收集他们比起需要的更多信息。一定比率的欺诈被视为是可能的。这种成本和不确定的交易是可被避免的当一个人是通过现实现金交易的方式，但是没有一个存在的机制来确保交易是通过一个没有可信方的通信通道进行支付的。</li>\n</ul>\n<p>这里也就可以发现一个区块链提出的很重要的目标：解决信任问题。在目前的网络体系中，第三方机构的存在使信任问题不可避免。而在另一方面，区块链天生具有不可逆与不可篡改的特性同样是我们经常需要追求的特性，尤其是诸如贸易、签署合同、投票、通信等场景。</p>\n<ul>\n<li>现在需要的就是一个基于密码学加密证明来替代信任的电子支付系统，允许任何两方能够在不需要一个可信的第三方的场景下直接交易。计算上保证的不可逆交易将会保护卖方免受欺诈，并且常规的托管机制可以很容易的被实现来保护买方。在这篇论文里，我们提出一种方案来解决双重支付问题，使用一种P2P分布式的时间戳服务来生成交易的时间顺序的计算证明。只要诚实节点比合作攻击的节点控制了更多的CPU计算力，那么整个系统就是安全的。</li>\n</ul>\n<p>这里指出，实际上信任问题是由原来的机构或者其他的信任转移到了“密码学加密”的数学体系上，变为了是否相信数学是可靠的问题。但是后一句的语言表达上实际上暗示了区块链这个体系实际上是支付方比接收方更具备一点优势，不是绝对平等的地位，所以接收方需要担心支付方的攻击(二次支付)。最后说明，区块链解决两重支付，基础的拓扑结构是P2P，时间戳是确认交易顺序的方式。</p>\n<ul>\n<li><p>我们定义一枚电子硬币为一些数字签名形成的链。每一个所有者通过对之前的交易和下一个所有者的公钥的一个散列值进行数字签名并将其附在硬币的末尾来把硬币交易给下一个人。一个接受者可以通过确认签名来确认这条所有权链(chain of ownership)。</p>\n<img src=\"/2018/01/20/区块链学习笔记（一）/snipaste20180118_002602.jpg\" title=\"区块链简略示意图\">\n</li>\n</ul>\n<p>论文中的电子硬币实际上是一条链</p>\n<ul>\n<li><p>这个过程的问题是收款人不能验证付款人中(one of the owners)没有人双重支付货币。一个常用的解决方案是引入一个可信的中央认证，或铸币厂(mint)，来对每一笔交易检查是否被双重支付。在每一笔交易后，这个货币必须被返回到铸币场来发行一枚新的硬币，并且只有货币被直接的从可信的铸币厂发行才能保证不被双重支付。这个解决方案的问题是全部货币(money)的命运都依靠在这个公司运作的铸币厂上，每一笔交易都必须通过他们，就像一个银行一样。</p>\n<p>我们提出的方案以一个时间戳服务器开始。一个时间戳服务器的工作就是把一组等待加上时间戳的物品(item)形成的区块(block)进行散列并将其广播。时间戳证明在那个时间必然存在，显然的，为了获得那个散列值。每个时间戳包括之前的时间戳在自己的散列值中(Each timestamp includes the previous timestamp in its hash)，形成了一条链，随着每个新的时间戳都加强了这个之前所有的时间戳。<img src=\"/2018/01/20/区块链学习笔记（一）/snipaste20180118_004710.jpg\" title=\"test\"></p>\n</li>\n<li><p>为了在点对点的基础上实现一个分布式的时间戳服务器，我们需要使用类似于Adam Back的<a href=\"http://www.hashcash.org/papers/hashcash.pdf\" target=\"_blank\" rel=\"noopener\">Hashcash</a>的工作量证明(PoW, proof-of-work)，而不是报纸或者世界新闻网络组。工作量证明机制引入在散列的时候对一个  值的扫描(scan)，例如在SHA-256下，这个散列从一串0开始。需要的平均工作与所需0数成指数关系，并且可以通过执行简单的(或者单个的？)(single)散列函数来被验证。</p>\n</li>\n<li><p>对于我们的时间戳网络，我们通过在后面增加一个随机串(nonce)来落实PoW，直到添加的随机串使得区块的散列值达到了所需的0数。一旦CPU效率被花费来满足工作量证明，除非重做相应的工作这个区块不能再被改变。随着之后有新区快链接上，改变单个区块将需要重做所有之后区块所对应的工作。（下图比上图更贴近区块链中区块的真实结构）</p>\n<img src=\"/2018/01/20/区块链学习笔记（一）/snipaste20180118_013210.jpg\" title=\"test\">\n</li>\n<li><p>工作量证明同时解决了多数决策中决定代表的问题。如果大多数人只根据一人一ip进行投票(one-IP-one_vote)，这样会被任何能够分配很多ip的人破坏。工作量证明本质上是一CPU一票(one-CPU-one-vote)。主要的(大多数)的决定是由最长的链所代表，最长链拥有最大的工作量花费在其中。如果一个大多数CPU算力都被诚实节点所控制，那么最诚实的链就会增长的最快且超过其他任何计算链。想要改变一个过去的区块，攻击者需要重做这个区块和所有在这个块后的区块的工作量证明，之后还要追赶上并超过现在所有诚实节点的工作。我们之后会说明，一个慢速的攻击者能够追赶上的可能性将会随着后续的块被添加指数级的减少。</p>\n</li>\n</ul>\n<h2 id=\"画个图总结一下\"><a href=\"#画个图总结一下\" class=\"headerlink\" title=\"画个图总结一下\"></a>画个图总结一下</h2><img src=\"/2018/01/20/区块链学习笔记（一）/新文档_2018-01-18_1.jpg\" title=\"test\">"},{"title":"完成一个C语言http服务器压力测试工具（一）","connments":true,"date":"2018-03-15T14:30:41.000Z","desc":"完成一个C语言http服务器压力测试工具（一）","summary":"复习加深入了解的机会~","_content":"\n一直没有机会拿C/cpp写点有意思的东西，其实内心还是有点戚戚然的，然后这次正好赶上机会了，感觉这个东西代码量也不大，原理值得琢磨，蛮开心的~\n\n# 0x0 计划\n\n个人认为此次工具要攻克的点在于如何用尽可能低的资源来完成压力测试工具。初步的计划是\n\n- 实现http连接\n- 加入多线程\n- 加入线程内并发连接\n- 优化\n- 优化\n- 无尽的优化\n\n个人理解来一份好的代码总是需要经历重构的，而个人感受来说，过早优化经常会产生第二系统效应，因为精益求精反而连个能用的结果都做不出来\n\n每次都只增加一点东西，但是测试好结果再继续，这样先把东西做出来，做得差不多了再重构\n\n## 学习资料\n\nhttps://stackoverflow.com/\n\nhttp://man7.org/index.html\n\n《Linux/UNIX系统编程手册》\n\n《UNIX网络编程 卷1：套接字API（第三版）》\n\n# 0x1 完成一次http连接\n\n先把最基础的东西实现了，直接上代码然后慢慢看吧\n\n```c\n#include <stdio.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n\ntypedef int file_descriptor;\n\nint main() {\n    const int port = 80;\n    char *host = \"localhost\";\n    char *request = \"GET http://10.10.10.138/ HTTP/1.1\\r\\n\"\n            \"Host: 10.10.10.138\\r\\n\"\n            \"Connection: keep-alive\\r\\n\"\n            \"Cache-Control: max-age=0\\r\\n\"\n            \"Upgrade-Insecure-Requests: 1\\r\\n\"\n            \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"\n            \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"\n            \"Accept-Encoding: gzip, deflate\\r\\n\"\n            \"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\";\n    int request_length = strlen(request);\n    struct hostent *server;\n    struct sockaddr_in serverAddr;\n    char response[8192] = {};\n    size_t total, sent, received = 0;\n    ssize_t bytes;\n\n    file_descriptor sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        printf(\"Failed Opening socket.\\n\");\n        return 1;\n    }\n\n    server = gethostbyname(host);\n    if (server == NULL) {\n        printf(\"No Such Host.\\n\");\n        return 1;\n    }\n\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    memcpy(&serverAddr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n    if(connect(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0){\n        printf(\"Failed connecting.\\n\");\n        return 1;\n    }\n\n    total = strlen(request);\n    sent = 0;\n    do {\n        bytes = send(sock, request, request_lenth, 0);\n        if (bytes < 0){\n            printf(\"Failed writing message to socket\\n\");\n            return 1;\n        }\n        if (bytes == 0)\n            break;\n        sent+=bytes;\n    } while (sent < total);\n\n    recv(sock, response, sizeof(response) - 1, 0);\n    \n    close(sockfd);\n\n    printf(\"Response:\\n%s\\n\",response);\n\n    return 0;\n}\n```\n\n现在先来分析一下这个简单的单次连接程序\n\n首先HTTP请求的大致过程是：\n\n- 浏览器与服务器建立一个**可靠**连接\n- 浏览器发出请求(request)\n- 服务器做出响应(response)\n- 断开连接\n\n所以如果用C来写的话，大概可以分为以下步骤：\n\n- 创建一个类型为SOCK_STREAM的socket（原因之后分析）\n- 建立与服务器的连接，如果没有服务器的具体信息，需要通过调用方法来获得\n- 发出请求\n- 等待响应\n- 关闭socket\n\n现在开始一步步把程序写出来\n\n## 创建socket\n\n```c\n    file_descriptor sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        printf(\"Failed Opening socket.\\n\");\n        return 1;\n    }\n\n```\n\n创建连接的时候就需要调用Linux底层提供的socket函数，如果创建socket成功，就会返回一个最小的能用的文件描述符（一个无符号整数），否则返回负数表示失败。函数原型为\n\n```c\nint socket(int domain, int type, int protocol);\n```\n\n该函数有三个参数，第一个参数指定socket domain，用处是识别socket地址格式，另一个是确定通信范围，比如AF_UNIX用来作为本地通信，AF_INET表示在使用IPv4网络的主机间通信。这里用来本机测试的话，AF_UNIX或者AF_INET都行，不过后面考虑把测试用的虚拟机和架设服务器的虚拟机分开以求不互相影响，所以用了后者。\n\n第二个参数指定socket类型，SOCK_STREAM类型提供面向连接的可靠数据传送，那这个不就是能达到一个TCP的嘛，而在《Linux/UNIX系统编程手册》P947上也有提到，“流socket（通常）采用了TCP”。因为http底层需要可靠数据连接服务，所以直接用SOCK_STREAM就行。同时Linux在内核2.6.27之后为这个参数增加了一个用途，允许两个标记与socket类型取或，来使得内核为返回的文件描述符启用close-on-exec或者使得该socket上发生的I/O变成非阻塞的。\n\n第三个参数是用于确定协议族下的特定协议的，但是在通常大多数情况下，只需要留给它0就行了。\n\n## 调用方法获得地址的信息\n\n```c\n    server = gethostbyname(host);\n    if (server == NULL) {\n        printf(\"No Such Host.\\n\");\n        return 1;\n    }\n\n\tbzero(&serverAddr, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    memcpy(&serverAddr.sin_addr.s_addr, server->h_addr, server->h_length);\n```\n\ngethostbyname(char *)如函数名一样直接，该方法通过DNS、host文件来从主机名或者IPv4地址获得具体的信息，如果是IPv4地址，则不会使用DNS。函数若成功返回一个指向包含该服务器信息的hostent结构的指针，否则返回NULL。\n\n这里还有一点值得一提，h(ost)to(net)s函数，做的就是字节序转换，因为网络通信常用大端序，而主机上又以小端序为主，所以如果亲自实现这些接口的话就需要注意这一点。\n\n至于为什么后面四行要那样写，个人理解来就是根据函数的接口与结构体定义，类似一个八股文的形式了。\n\n## 建立连接\n\n```c\n    if(connect(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0){\n        printf(\"Failed connecting.\\n\");\n        return 1;\n    }\n```\n\n先放下这个函数的原型\n\n``` c\nint connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n```\n\n第一个参数就是我们在第一步里面获得的文件描述符，第二个则是第二步里获得的地址信息，第三个参数是addr的大小。\n\n记得之前说的吗，可以通过在socket()第二个参数socket使用或使socket上发生的I/O变成非阻塞的，但是如果那样做的话，在这里就会返回一个-1，并将errno（如果引入errno.h）置为115（EINPROGRESS），但是已经发起的握手其实是继续进行的，这里处理操作设计I/O复用，目前预计在第三篇中学习。\n\n## 发起请求\n\n```c\n    total = strlen(request);\n    sent = 0;\n    do {\n        bytes = send(sock, request, request_lenth, 0);\n        if (bytes < 0){\n            printf(\"Failed writing message to socket\\n\");\n            return 1;\n        }\n        if (bytes == 0)\n            break;\n        sent+=bytes;\n    } while (sent < total);\n```\n\n这个感觉也是个八股文的东西吧，就是尝试把请求发出去。请求内容我是直接访问了一次网站，抓了一次包，去掉了最后一个确定是否更改的标记。\n\n对socket进行操作的时候，send和write两个的效果几乎是一样的，不同点在于send最后传入一个flag参数，用于提供诸如不使用网关等额外操作。此外send用在非I/O模式的socket上是非阻塞的，但是write总是会阻塞的。\n\n## 等待响应\n\n``` c\n\tdo {\n    \trecv(sockfd, response, sizeof(response) - 1, 0);\n        if (bytes < 0){\n            printf(\"Failed writing message to socket\\n\");\n            return 1;\n        }\n        if (bytes == 0)\n            break;\n        sent+=bytes;\n    } while (sent < total);\n```\n\n一样的操作。\n\n对socket进行操作时，recv与read两个的异同和send与write间的关系类似。\n\n# 0x2 总结与挖掘\n\n第一篇笔记，简单实现了C语言的http请求与响应。\n\n在这篇中，我觉得还可以深挖的东西有：\n\n- 文件描述符是什么？它的范围是怎么样的？对它的操作涉及什么？\n- socket的类型中还有其他可以提供可靠连接的类型，是否也能用它实现http请求？\n\n对于以上问题，目前有的答案是：\n\n- 所有执行I/O操作的系统调用都以文件描述符来之指代一个打开的文件，此处的文件并非一个狭窄的概念，pipe、FIFO、socket、终端、设备和普通文件都被囊括在这一范围内，它被表示为一个非负整数（通常用可以使用的最小非负整数，所以这也解释了为什么错误处理的时候是检测返回文件描述符是否为负）。在Linux系统中，可以通过查看`cat /proc/sys/fs/file-max`来确定系统中能用的文件描述符总量，但是在一个进程中打开过多文件描述符会返回一个“too many open files”错误，对于单个进程的文件描述符数量上限可以使用`ulimit -a`查看，同时可以依照下篇笔记中的博客对Ubuntu12/14/16进行调整。对文件描述符的操作其实就是I/O操作。\n- 这是一个需要实践的问题，我暂时还没有进行尝试。","source":"_posts/完成一个C语言http服务器压力测试工具（一）.md","raw":"---\ntitle: 完成一个C语言http服务器压力测试工具（一）\nconnments: true\ndate: 2018-03-15 22:30:41\ntags: \n\t- C\n\t- Software Development\ncategories: Notes\ndesc: 完成一个C语言http服务器压力测试工具（一）\nsummary: 复习加深入了解的机会~\n---\n\n一直没有机会拿C/cpp写点有意思的东西，其实内心还是有点戚戚然的，然后这次正好赶上机会了，感觉这个东西代码量也不大，原理值得琢磨，蛮开心的~\n\n# 0x0 计划\n\n个人认为此次工具要攻克的点在于如何用尽可能低的资源来完成压力测试工具。初步的计划是\n\n- 实现http连接\n- 加入多线程\n- 加入线程内并发连接\n- 优化\n- 优化\n- 无尽的优化\n\n个人理解来一份好的代码总是需要经历重构的，而个人感受来说，过早优化经常会产生第二系统效应，因为精益求精反而连个能用的结果都做不出来\n\n每次都只增加一点东西，但是测试好结果再继续，这样先把东西做出来，做得差不多了再重构\n\n## 学习资料\n\nhttps://stackoverflow.com/\n\nhttp://man7.org/index.html\n\n《Linux/UNIX系统编程手册》\n\n《UNIX网络编程 卷1：套接字API（第三版）》\n\n# 0x1 完成一次http连接\n\n先把最基础的东西实现了，直接上代码然后慢慢看吧\n\n```c\n#include <stdio.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <string.h>\n\ntypedef int file_descriptor;\n\nint main() {\n    const int port = 80;\n    char *host = \"localhost\";\n    char *request = \"GET http://10.10.10.138/ HTTP/1.1\\r\\n\"\n            \"Host: 10.10.10.138\\r\\n\"\n            \"Connection: keep-alive\\r\\n\"\n            \"Cache-Control: max-age=0\\r\\n\"\n            \"Upgrade-Insecure-Requests: 1\\r\\n\"\n            \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"\n            \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"\n            \"Accept-Encoding: gzip, deflate\\r\\n\"\n            \"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\";\n    int request_length = strlen(request);\n    struct hostent *server;\n    struct sockaddr_in serverAddr;\n    char response[8192] = {};\n    size_t total, sent, received = 0;\n    ssize_t bytes;\n\n    file_descriptor sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        printf(\"Failed Opening socket.\\n\");\n        return 1;\n    }\n\n    server = gethostbyname(host);\n    if (server == NULL) {\n        printf(\"No Such Host.\\n\");\n        return 1;\n    }\n\n    memset(&serverAddr, 0, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    memcpy(&serverAddr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n    if(connect(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0){\n        printf(\"Failed connecting.\\n\");\n        return 1;\n    }\n\n    total = strlen(request);\n    sent = 0;\n    do {\n        bytes = send(sock, request, request_lenth, 0);\n        if (bytes < 0){\n            printf(\"Failed writing message to socket\\n\");\n            return 1;\n        }\n        if (bytes == 0)\n            break;\n        sent+=bytes;\n    } while (sent < total);\n\n    recv(sock, response, sizeof(response) - 1, 0);\n    \n    close(sockfd);\n\n    printf(\"Response:\\n%s\\n\",response);\n\n    return 0;\n}\n```\n\n现在先来分析一下这个简单的单次连接程序\n\n首先HTTP请求的大致过程是：\n\n- 浏览器与服务器建立一个**可靠**连接\n- 浏览器发出请求(request)\n- 服务器做出响应(response)\n- 断开连接\n\n所以如果用C来写的话，大概可以分为以下步骤：\n\n- 创建一个类型为SOCK_STREAM的socket（原因之后分析）\n- 建立与服务器的连接，如果没有服务器的具体信息，需要通过调用方法来获得\n- 发出请求\n- 等待响应\n- 关闭socket\n\n现在开始一步步把程序写出来\n\n## 创建socket\n\n```c\n    file_descriptor sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        printf(\"Failed Opening socket.\\n\");\n        return 1;\n    }\n\n```\n\n创建连接的时候就需要调用Linux底层提供的socket函数，如果创建socket成功，就会返回一个最小的能用的文件描述符（一个无符号整数），否则返回负数表示失败。函数原型为\n\n```c\nint socket(int domain, int type, int protocol);\n```\n\n该函数有三个参数，第一个参数指定socket domain，用处是识别socket地址格式，另一个是确定通信范围，比如AF_UNIX用来作为本地通信，AF_INET表示在使用IPv4网络的主机间通信。这里用来本机测试的话，AF_UNIX或者AF_INET都行，不过后面考虑把测试用的虚拟机和架设服务器的虚拟机分开以求不互相影响，所以用了后者。\n\n第二个参数指定socket类型，SOCK_STREAM类型提供面向连接的可靠数据传送，那这个不就是能达到一个TCP的嘛，而在《Linux/UNIX系统编程手册》P947上也有提到，“流socket（通常）采用了TCP”。因为http底层需要可靠数据连接服务，所以直接用SOCK_STREAM就行。同时Linux在内核2.6.27之后为这个参数增加了一个用途，允许两个标记与socket类型取或，来使得内核为返回的文件描述符启用close-on-exec或者使得该socket上发生的I/O变成非阻塞的。\n\n第三个参数是用于确定协议族下的特定协议的，但是在通常大多数情况下，只需要留给它0就行了。\n\n## 调用方法获得地址的信息\n\n```c\n    server = gethostbyname(host);\n    if (server == NULL) {\n        printf(\"No Such Host.\\n\");\n        return 1;\n    }\n\n\tbzero(&serverAddr, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    memcpy(&serverAddr.sin_addr.s_addr, server->h_addr, server->h_length);\n```\n\ngethostbyname(char *)如函数名一样直接，该方法通过DNS、host文件来从主机名或者IPv4地址获得具体的信息，如果是IPv4地址，则不会使用DNS。函数若成功返回一个指向包含该服务器信息的hostent结构的指针，否则返回NULL。\n\n这里还有一点值得一提，h(ost)to(net)s函数，做的就是字节序转换，因为网络通信常用大端序，而主机上又以小端序为主，所以如果亲自实现这些接口的话就需要注意这一点。\n\n至于为什么后面四行要那样写，个人理解来就是根据函数的接口与结构体定义，类似一个八股文的形式了。\n\n## 建立连接\n\n```c\n    if(connect(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0){\n        printf(\"Failed connecting.\\n\");\n        return 1;\n    }\n```\n\n先放下这个函数的原型\n\n``` c\nint connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n```\n\n第一个参数就是我们在第一步里面获得的文件描述符，第二个则是第二步里获得的地址信息，第三个参数是addr的大小。\n\n记得之前说的吗，可以通过在socket()第二个参数socket使用或使socket上发生的I/O变成非阻塞的，但是如果那样做的话，在这里就会返回一个-1，并将errno（如果引入errno.h）置为115（EINPROGRESS），但是已经发起的握手其实是继续进行的，这里处理操作设计I/O复用，目前预计在第三篇中学习。\n\n## 发起请求\n\n```c\n    total = strlen(request);\n    sent = 0;\n    do {\n        bytes = send(sock, request, request_lenth, 0);\n        if (bytes < 0){\n            printf(\"Failed writing message to socket\\n\");\n            return 1;\n        }\n        if (bytes == 0)\n            break;\n        sent+=bytes;\n    } while (sent < total);\n```\n\n这个感觉也是个八股文的东西吧，就是尝试把请求发出去。请求内容我是直接访问了一次网站，抓了一次包，去掉了最后一个确定是否更改的标记。\n\n对socket进行操作的时候，send和write两个的效果几乎是一样的，不同点在于send最后传入一个flag参数，用于提供诸如不使用网关等额外操作。此外send用在非I/O模式的socket上是非阻塞的，但是write总是会阻塞的。\n\n## 等待响应\n\n``` c\n\tdo {\n    \trecv(sockfd, response, sizeof(response) - 1, 0);\n        if (bytes < 0){\n            printf(\"Failed writing message to socket\\n\");\n            return 1;\n        }\n        if (bytes == 0)\n            break;\n        sent+=bytes;\n    } while (sent < total);\n```\n\n一样的操作。\n\n对socket进行操作时，recv与read两个的异同和send与write间的关系类似。\n\n# 0x2 总结与挖掘\n\n第一篇笔记，简单实现了C语言的http请求与响应。\n\n在这篇中，我觉得还可以深挖的东西有：\n\n- 文件描述符是什么？它的范围是怎么样的？对它的操作涉及什么？\n- socket的类型中还有其他可以提供可靠连接的类型，是否也能用它实现http请求？\n\n对于以上问题，目前有的答案是：\n\n- 所有执行I/O操作的系统调用都以文件描述符来之指代一个打开的文件，此处的文件并非一个狭窄的概念，pipe、FIFO、socket、终端、设备和普通文件都被囊括在这一范围内，它被表示为一个非负整数（通常用可以使用的最小非负整数，所以这也解释了为什么错误处理的时候是检测返回文件描述符是否为负）。在Linux系统中，可以通过查看`cat /proc/sys/fs/file-max`来确定系统中能用的文件描述符总量，但是在一个进程中打开过多文件描述符会返回一个“too many open files”错误，对于单个进程的文件描述符数量上限可以使用`ulimit -a`查看，同时可以依照下篇笔记中的博客对Ubuntu12/14/16进行调整。对文件描述符的操作其实就是I/O操作。\n- 这是一个需要实践的问题，我暂时还没有进行尝试。","slug":"完成一个C语言http服务器压力测试工具（一）","published":1,"updated":"2018-03-19T15:15:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgqnsczm0007dkudzdpq45jn","content":"<p>一直没有机会拿C/cpp写点有意思的东西，其实内心还是有点戚戚然的，然后这次正好赶上机会了，感觉这个东西代码量也不大，原理值得琢磨，蛮开心的~</p>\n<h1 id=\"0x0-计划\"><a href=\"#0x0-计划\" class=\"headerlink\" title=\"0x0 计划\"></a>0x0 计划</h1><p>个人认为此次工具要攻克的点在于如何用尽可能低的资源来完成压力测试工具。初步的计划是</p>\n<ul>\n<li>实现http连接</li>\n<li>加入多线程</li>\n<li>加入线程内并发连接</li>\n<li>优化</li>\n<li>优化</li>\n<li>无尽的优化</li>\n</ul>\n<p>个人理解来一份好的代码总是需要经历重构的，而个人感受来说，过早优化经常会产生第二系统效应，因为精益求精反而连个能用的结果都做不出来</p>\n<p>每次都只增加一点东西，但是测试好结果再继续，这样先把东西做出来，做得差不多了再重构</p>\n<h2 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h2><p><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/</a></p>\n<p><a href=\"http://man7.org/index.html\" target=\"_blank\" rel=\"noopener\">http://man7.org/index.html</a></p>\n<p>《Linux/UNIX系统编程手册》</p>\n<p>《UNIX网络编程 卷1：套接字API（第三版）》</p>\n<h1 id=\"0x1-完成一次http连接\"><a href=\"#0x1-完成一次http连接\" class=\"headerlink\" title=\"0x1 完成一次http连接\"></a>0x1 完成一次http连接</h1><p>先把最基础的东西实现了，直接上代码然后慢慢看吧</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> file_descriptor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port = <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *host = <span class=\"string\">\"localhost\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *request = <span class=\"string\">\"GET http://10.10.10.138/ HTTP/1.1\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Host: 10.10.10.138\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Connection: keep-alive\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Cache-Control: max-age=0\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Upgrade-Insecure-Requests: 1\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Accept-Encoding: gzip, deflate\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> request_length = <span class=\"built_in\">strlen</span>(request);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">server</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> response[<span class=\"number\">8192</span>] = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> total, sent, received = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> bytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    file_descriptor sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed Opening socket.\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server = gethostbyname(host);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (server == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"No Such Host.\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;serverAddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(port);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;serverAddr.sin_addr.s_addr, server-&gt;h_addr, server-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(connect(sockfd, (struct sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr)) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed connecting.\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    total = <span class=\"built_in\">strlen</span>(request);</span><br><span class=\"line\">    sent = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        bytes = send(sock, request, request_lenth, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bytes &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed writing message to socket\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bytes == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        sent+=bytes;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (sent &lt; total);</span><br><span class=\"line\"></span><br><span class=\"line\">    recv(sock, response, <span class=\"keyword\">sizeof</span>(response) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    close(sockfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Response:\\n%s\\n\"</span>,response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在先来分析一下这个简单的单次连接程序</p>\n<p>首先HTTP请求的大致过程是：</p>\n<ul>\n<li>浏览器与服务器建立一个<strong>可靠</strong>连接</li>\n<li>浏览器发出请求(request)</li>\n<li>服务器做出响应(response)</li>\n<li>断开连接</li>\n</ul>\n<p>所以如果用C来写的话，大概可以分为以下步骤：</p>\n<ul>\n<li>创建一个类型为SOCK_STREAM的socket（原因之后分析）</li>\n<li>建立与服务器的连接，如果没有服务器的具体信息，需要通过调用方法来获得</li>\n<li>发出请求</li>\n<li>等待响应</li>\n<li>关闭socket</li>\n</ul>\n<p>现在开始一步步把程序写出来</p>\n<h2 id=\"创建socket\"><a href=\"#创建socket\" class=\"headerlink\" title=\"创建socket\"></a>创建socket</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file_descriptor sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed Opening socket.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建连接的时候就需要调用Linux底层提供的socket函数，如果创建socket成功，就会返回一个最小的能用的文件描述符（一个无符号整数），否则返回负数表示失败。函数原型为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>该函数有三个参数，第一个参数指定socket domain，用处是识别socket地址格式，另一个是确定通信范围，比如AF_UNIX用来作为本地通信，AF_INET表示在使用IPv4网络的主机间通信。这里用来本机测试的话，AF_UNIX或者AF_INET都行，不过后面考虑把测试用的虚拟机和架设服务器的虚拟机分开以求不互相影响，所以用了后者。</p>\n<p>第二个参数指定socket类型，SOCK_STREAM类型提供面向连接的可靠数据传送，那这个不就是能达到一个TCP的嘛，而在《Linux/UNIX系统编程手册》P947上也有提到，“流socket（通常）采用了TCP”。因为http底层需要可靠数据连接服务，所以直接用SOCK_STREAM就行。同时Linux在内核2.6.27之后为这个参数增加了一个用途，允许两个标记与socket类型取或，来使得内核为返回的文件描述符启用close-on-exec或者使得该socket上发生的I/O变成非阻塞的。</p>\n<p>第三个参数是用于确定协议族下的特定协议的，但是在通常大多数情况下，只需要留给它0就行了。</p>\n<h2 id=\"调用方法获得地址的信息\"><a href=\"#调用方法获得地址的信息\" class=\"headerlink\" title=\"调用方法获得地址的信息\"></a>调用方法获得地址的信息</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   server = gethostbyname(host);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (server == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"No Such Host.\\n\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bzero(&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">   serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">   serverAddr.sin_port = htons(port);</span><br><span class=\"line\">   <span class=\"built_in\">memcpy</span>(&amp;serverAddr.sin_addr.s_addr, server-&gt;h_addr, server-&gt;h_length);</span><br></pre></td></tr></table></figure>\n<p>gethostbyname(char *)如函数名一样直接，该方法通过DNS、host文件来从主机名或者IPv4地址获得具体的信息，如果是IPv4地址，则不会使用DNS。函数若成功返回一个指向包含该服务器信息的hostent结构的指针，否则返回NULL。</p>\n<p>这里还有一点值得一提，h(ost)to(net)s函数，做的就是字节序转换，因为网络通信常用大端序，而主机上又以小端序为主，所以如果亲自实现这些接口的话就需要注意这一点。</p>\n<p>至于为什么后面四行要那样写，个人理解来就是根据函数的接口与结构体定义，类似一个八股文的形式了。</p>\n<h2 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(connect(sockfd, (struct sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr)) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed connecting.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先放下这个函数的原型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr *addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>第一个参数就是我们在第一步里面获得的文件描述符，第二个则是第二步里获得的地址信息，第三个参数是addr的大小。</p>\n<p>记得之前说的吗，可以通过在socket()第二个参数socket使用或使socket上发生的I/O变成非阻塞的，但是如果那样做的话，在这里就会返回一个-1，并将errno（如果引入errno.h）置为115（EINPROGRESS），但是已经发起的握手其实是继续进行的，这里处理操作设计I/O复用，目前预计在第三篇中学习。</p>\n<h2 id=\"发起请求\"><a href=\"#发起请求\" class=\"headerlink\" title=\"发起请求\"></a>发起请求</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total = <span class=\"built_in\">strlen</span>(request);</span><br><span class=\"line\">sent = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    bytes = send(sock, request, request_lenth, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bytes &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed writing message to socket\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bytes == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    sent+=bytes;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (sent &lt; total);</span><br></pre></td></tr></table></figure>\n<p>这个感觉也是个八股文的东西吧，就是尝试把请求发出去。请求内容我是直接访问了一次网站，抓了一次包，去掉了最后一个确定是否更改的标记。</p>\n<p>对socket进行操作的时候，send和write两个的效果几乎是一样的，不同点在于send最后传入一个flag参数，用于提供诸如不使用网关等额外操作。此外send用在非I/O模式的socket上是非阻塞的，但是write总是会阻塞的。</p>\n<h2 id=\"等待响应\"><a href=\"#等待响应\" class=\"headerlink\" title=\"等待响应\"></a>等待响应</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">   \trecv(sockfd, response, <span class=\"keyword\">sizeof</span>(response) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (bytes &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed writing message to socket\\n\"</span>);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (bytes == <span class=\"number\">0</span>)</span><br><span class=\"line\">           <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       sent+=bytes;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">while</span> (sent &lt; total);</span><br></pre></td></tr></table></figure>\n<p>一样的操作。</p>\n<p>对socket进行操作时，recv与read两个的异同和send与write间的关系类似。</p>\n<h1 id=\"0x2-总结与挖掘\"><a href=\"#0x2-总结与挖掘\" class=\"headerlink\" title=\"0x2 总结与挖掘\"></a>0x2 总结与挖掘</h1><p>第一篇笔记，简单实现了C语言的http请求与响应。</p>\n<p>在这篇中，我觉得还可以深挖的东西有：</p>\n<ul>\n<li>文件描述符是什么？它的范围是怎么样的？对它的操作涉及什么？</li>\n<li>socket的类型中还有其他可以提供可靠连接的类型，是否也能用它实现http请求？</li>\n</ul>\n<p>对于以上问题，目前有的答案是：</p>\n<ul>\n<li>所有执行I/O操作的系统调用都以文件描述符来之指代一个打开的文件，此处的文件并非一个狭窄的概念，pipe、FIFO、socket、终端、设备和普通文件都被囊括在这一范围内，它被表示为一个非负整数（通常用可以使用的最小非负整数，所以这也解释了为什么错误处理的时候是检测返回文件描述符是否为负）。在Linux系统中，可以通过查看<code>cat /proc/sys/fs/file-max</code>来确定系统中能用的文件描述符总量，但是在一个进程中打开过多文件描述符会返回一个“too many open files”错误，对于单个进程的文件描述符数量上限可以使用<code>ulimit -a</code>查看，同时可以依照下篇笔记中的博客对Ubuntu12/14/16进行调整。对文件描述符的操作其实就是I/O操作。</li>\n<li>这是一个需要实践的问题，我暂时还没有进行尝试。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>一直没有机会拿C/cpp写点有意思的东西，其实内心还是有点戚戚然的，然后这次正好赶上机会了，感觉这个东西代码量也不大，原理值得琢磨，蛮开心的~</p>\n<h1 id=\"0x0-计划\"><a href=\"#0x0-计划\" class=\"headerlink\" title=\"0x0 计划\"></a>0x0 计划</h1><p>个人认为此次工具要攻克的点在于如何用尽可能低的资源来完成压力测试工具。初步的计划是</p>\n<ul>\n<li>实现http连接</li>\n<li>加入多线程</li>\n<li>加入线程内并发连接</li>\n<li>优化</li>\n<li>优化</li>\n<li>无尽的优化</li>\n</ul>\n<p>个人理解来一份好的代码总是需要经历重构的，而个人感受来说，过早优化经常会产生第二系统效应，因为精益求精反而连个能用的结果都做不出来</p>\n<p>每次都只增加一点东西，但是测试好结果再继续，这样先把东西做出来，做得差不多了再重构</p>\n<h2 id=\"学习资料\"><a href=\"#学习资料\" class=\"headerlink\" title=\"学习资料\"></a>学习资料</h2><p><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/</a></p>\n<p><a href=\"http://man7.org/index.html\" target=\"_blank\" rel=\"noopener\">http://man7.org/index.html</a></p>\n<p>《Linux/UNIX系统编程手册》</p>\n<p>《UNIX网络编程 卷1：套接字API（第三版）》</p>\n<h1 id=\"0x1-完成一次http连接\"><a href=\"#0x1-完成一次http连接\" class=\"headerlink\" title=\"0x1 完成一次http连接\"></a>0x1 完成一次http连接</h1><p>先把最基础的东西实现了，直接上代码然后慢慢看吧</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> file_descriptor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port = <span class=\"number\">80</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *host = <span class=\"string\">\"localhost\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *request = <span class=\"string\">\"GET http://10.10.10.138/ HTTP/1.1\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Host: 10.10.10.138\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Connection: keep-alive\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Cache-Control: max-age=0\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Upgrade-Insecure-Requests: 1\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Accept-Encoding: gzip, deflate\\r\\n\"</span></span><br><span class=\"line\">            <span class=\"string\">\"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> request_length = <span class=\"built_in\">strlen</span>(request);</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">server</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> response[<span class=\"number\">8192</span>] = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> total, sent, received = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> bytes;</span><br><span class=\"line\"></span><br><span class=\"line\">    file_descriptor sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed Opening socket.\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server = gethostbyname(host);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (server == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"No Such Host.\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;serverAddr, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(port);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;serverAddr.sin_addr.s_addr, server-&gt;h_addr, server-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(connect(sockfd, (struct sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr)) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed connecting.\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    total = <span class=\"built_in\">strlen</span>(request);</span><br><span class=\"line\">    sent = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        bytes = send(sock, request, request_lenth, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bytes &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed writing message to socket\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bytes == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        sent+=bytes;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (sent &lt; total);</span><br><span class=\"line\"></span><br><span class=\"line\">    recv(sock, response, <span class=\"keyword\">sizeof</span>(response) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    close(sockfd);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Response:\\n%s\\n\"</span>,response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在先来分析一下这个简单的单次连接程序</p>\n<p>首先HTTP请求的大致过程是：</p>\n<ul>\n<li>浏览器与服务器建立一个<strong>可靠</strong>连接</li>\n<li>浏览器发出请求(request)</li>\n<li>服务器做出响应(response)</li>\n<li>断开连接</li>\n</ul>\n<p>所以如果用C来写的话，大概可以分为以下步骤：</p>\n<ul>\n<li>创建一个类型为SOCK_STREAM的socket（原因之后分析）</li>\n<li>建立与服务器的连接，如果没有服务器的具体信息，需要通过调用方法来获得</li>\n<li>发出请求</li>\n<li>等待响应</li>\n<li>关闭socket</li>\n</ul>\n<p>现在开始一步步把程序写出来</p>\n<h2 id=\"创建socket\"><a href=\"#创建socket\" class=\"headerlink\" title=\"创建socket\"></a>创建socket</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file_descriptor sockfd = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed Opening socket.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建连接的时候就需要调用Linux底层提供的socket函数，如果创建socket成功，就会返回一个最小的能用的文件描述符（一个无符号整数），否则返回负数表示失败。函数原型为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>该函数有三个参数，第一个参数指定socket domain，用处是识别socket地址格式，另一个是确定通信范围，比如AF_UNIX用来作为本地通信，AF_INET表示在使用IPv4网络的主机间通信。这里用来本机测试的话，AF_UNIX或者AF_INET都行，不过后面考虑把测试用的虚拟机和架设服务器的虚拟机分开以求不互相影响，所以用了后者。</p>\n<p>第二个参数指定socket类型，SOCK_STREAM类型提供面向连接的可靠数据传送，那这个不就是能达到一个TCP的嘛，而在《Linux/UNIX系统编程手册》P947上也有提到，“流socket（通常）采用了TCP”。因为http底层需要可靠数据连接服务，所以直接用SOCK_STREAM就行。同时Linux在内核2.6.27之后为这个参数增加了一个用途，允许两个标记与socket类型取或，来使得内核为返回的文件描述符启用close-on-exec或者使得该socket上发生的I/O变成非阻塞的。</p>\n<p>第三个参数是用于确定协议族下的特定协议的，但是在通常大多数情况下，只需要留给它0就行了。</p>\n<h2 id=\"调用方法获得地址的信息\"><a href=\"#调用方法获得地址的信息\" class=\"headerlink\" title=\"调用方法获得地址的信息\"></a>调用方法获得地址的信息</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   server = gethostbyname(host);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (server == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"No Such Host.\\n\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bzero(&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">   serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">   serverAddr.sin_port = htons(port);</span><br><span class=\"line\">   <span class=\"built_in\">memcpy</span>(&amp;serverAddr.sin_addr.s_addr, server-&gt;h_addr, server-&gt;h_length);</span><br></pre></td></tr></table></figure>\n<p>gethostbyname(char *)如函数名一样直接，该方法通过DNS、host文件来从主机名或者IPv4地址获得具体的信息，如果是IPv4地址，则不会使用DNS。函数若成功返回一个指向包含该服务器信息的hostent结构的指针，否则返回NULL。</p>\n<p>这里还有一点值得一提，h(ost)to(net)s函数，做的就是字节序转换，因为网络通信常用大端序，而主机上又以小端序为主，所以如果亲自实现这些接口的话就需要注意这一点。</p>\n<p>至于为什么后面四行要那样写，个人理解来就是根据函数的接口与结构体定义，类似一个八股文的形式了。</p>\n<h2 id=\"建立连接\"><a href=\"#建立连接\" class=\"headerlink\" title=\"建立连接\"></a>建立连接</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(connect(sockfd, (struct sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr)) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed connecting.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先放下这个函数的原型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr *addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>第一个参数就是我们在第一步里面获得的文件描述符，第二个则是第二步里获得的地址信息，第三个参数是addr的大小。</p>\n<p>记得之前说的吗，可以通过在socket()第二个参数socket使用或使socket上发生的I/O变成非阻塞的，但是如果那样做的话，在这里就会返回一个-1，并将errno（如果引入errno.h）置为115（EINPROGRESS），但是已经发起的握手其实是继续进行的，这里处理操作设计I/O复用，目前预计在第三篇中学习。</p>\n<h2 id=\"发起请求\"><a href=\"#发起请求\" class=\"headerlink\" title=\"发起请求\"></a>发起请求</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total = <span class=\"built_in\">strlen</span>(request);</span><br><span class=\"line\">sent = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    bytes = send(sock, request, request_lenth, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bytes &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed writing message to socket\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bytes == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    sent+=bytes;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (sent &lt; total);</span><br></pre></td></tr></table></figure>\n<p>这个感觉也是个八股文的东西吧，就是尝试把请求发出去。请求内容我是直接访问了一次网站，抓了一次包，去掉了最后一个确定是否更改的标记。</p>\n<p>对socket进行操作的时候，send和write两个的效果几乎是一样的，不同点在于send最后传入一个flag参数，用于提供诸如不使用网关等额外操作。此外send用在非I/O模式的socket上是非阻塞的，但是write总是会阻塞的。</p>\n<h2 id=\"等待响应\"><a href=\"#等待响应\" class=\"headerlink\" title=\"等待响应\"></a>等待响应</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">   \trecv(sockfd, response, <span class=\"keyword\">sizeof</span>(response) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (bytes &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           <span class=\"built_in\">printf</span>(<span class=\"string\">\"Failed writing message to socket\\n\"</span>);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (bytes == <span class=\"number\">0</span>)</span><br><span class=\"line\">           <span class=\"keyword\">break</span>;</span><br><span class=\"line\">       sent+=bytes;</span><br><span class=\"line\">   &#125; <span class=\"keyword\">while</span> (sent &lt; total);</span><br></pre></td></tr></table></figure>\n<p>一样的操作。</p>\n<p>对socket进行操作时，recv与read两个的异同和send与write间的关系类似。</p>\n<h1 id=\"0x2-总结与挖掘\"><a href=\"#0x2-总结与挖掘\" class=\"headerlink\" title=\"0x2 总结与挖掘\"></a>0x2 总结与挖掘</h1><p>第一篇笔记，简单实现了C语言的http请求与响应。</p>\n<p>在这篇中，我觉得还可以深挖的东西有：</p>\n<ul>\n<li>文件描述符是什么？它的范围是怎么样的？对它的操作涉及什么？</li>\n<li>socket的类型中还有其他可以提供可靠连接的类型，是否也能用它实现http请求？</li>\n</ul>\n<p>对于以上问题，目前有的答案是：</p>\n<ul>\n<li>所有执行I/O操作的系统调用都以文件描述符来之指代一个打开的文件，此处的文件并非一个狭窄的概念，pipe、FIFO、socket、终端、设备和普通文件都被囊括在这一范围内，它被表示为一个非负整数（通常用可以使用的最小非负整数，所以这也解释了为什么错误处理的时候是检测返回文件描述符是否为负）。在Linux系统中，可以通过查看<code>cat /proc/sys/fs/file-max</code>来确定系统中能用的文件描述符总量，但是在一个进程中打开过多文件描述符会返回一个“too many open files”错误，对于单个进程的文件描述符数量上限可以使用<code>ulimit -a</code>查看，同时可以依照下篇笔记中的博客对Ubuntu12/14/16进行调整。对文件描述符的操作其实就是I/O操作。</li>\n<li>这是一个需要实践的问题，我暂时还没有进行尝试。</li>\n</ul>\n"},{"title":"完成一个C语言http服务器压力测试工具（三）","connments":true,"date":"2018-03-19T14:09:47.000Z","desc":"完成一个C语言http服务器压力测试工具（三）","summary":"复习加深入了解的机会~","_content":"\n# 0x0 学习资料\n\n- 《UNIX网络编程 卷1：套接字API（第三版）》\n- 《Linux/UNIX系统编程手册》\n- [Epoll is fundamentally broken 1/2](https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/)\n- [Epoll is fundamentally broken 2/2](https://idea.popcount.org/2017-03-20-epoll-is-fundamentally-broken-22/)\n\n# 0x1 学习路途\n\n这次东西深入的比较多，所以先在前面尝试叙述一下学到的一点东西，然后从知识的基础上再来写程序。\n\n## 非阻塞I/O\n\n在上次实现的两个程序中，采用的都是阻塞型I/O模型，所谓阻塞性I/O模型就是指单个线程每次只在一个文件描述符上进行I/O操作（在本例中是一个socket），每次I/O系统调用都会一直阻塞直到完成数据传输，那么只需要出现以下这些情况，那么情况就会变得很麻烦：\n\n- 检查文件描述符上是否需要进行I/O\n- 对没有数据到来的socket调用了read()方法\n- 需要检查多个文件描述符，查看他们是否可执行I/O\n\n一旦阻塞上，只能等待操作完成才能进行下一步的操作，这对于许多追求效率的场合都是不能忍受的。于是目前的操作系统都引入了非阻塞I/O的方法。pipe、FIFO、socket、设备都支持非阻塞模式，除了open()外，对于socket、pipe这种无法通过open()获取文件描述符的文件来说，可以使用fcntl()的F_SETFL命令启用非阻塞标志。\n\n除此之外，对于我们所要使用的socket来说，可以在socket()函数的第二个参数中或上SOCK_NONBLOCK来使得socket变成非阻塞模式，需要注意的是，非阻塞模式的socket在进行connect()的时候会返回负值，并将errno置为EINPROGRESS。\n\n## I/O多路复用\n\n有了非阻塞I/O模型，那么我们就可以这样提升我们的效率：\n\n首先对目前有的文件描述符做一个检查，查看是否有可以执行I/O的文件描述符，然后对这些文件描述符执行I/O操作（例如这时可以为这个I/O新开一个线程/进程），这样我们的效率就提升上来了。\n\n但是显然不应该对已有的文件描述符形成的集合进行不停的遍历，这样效率会被浪费许多，好在Linux提供了一些I/O多路复用的接口，包括select/poll/epoll(Linux 2.6+)\n\n做一个粗略的比较的话，如果限定在Linux平台上，那么epoll无疑是最好的选择，原因有以下几个：\n\n- 文件描述符范围有限制。select底层用数组实现，最大连接数写死\n- 时间复杂度为O(n)。select/poll在获得事件数后，都需要进行遍历来确认。\n- 文件描述符拷贝。每次调用select/poll的时候，都会有一次拷贝。\n\nselect/poll/epoll作为三个比较成熟的I/O复用模型，还有很多值得说的东西，但介于一个自己能力不够，另一个时间太少，没法在这里展开叙述了。\n\n## 多线程I/O复用\n\n多线程使用epoll的时候，就需要考虑以下问题：\n\n- 各线程的epoll是否是同一个？\n  - 如果是的话，如何保证调用epoll_wait()获得的event是独立的\n  - 如果不是的话，建立连接的线程该向哪个epoll file descriptor添加\n- 各线程的epoll_event是否是同一个？\n  - 如果是的话，如何保证他们处理的event是互斥的\n  - 如果不是的话，如何保证他们分别的epoll_event交际是空的\n- 如何保证各线程处理的socket没有交集？\n\n以及有关性能的其他考虑：\n\n- 考虑这样的情况，如果多个处理连接的线程都闲置了，此时突然来了一个I/O请求，会不会发生多线程的争抢？或者单纯多个线程的唤醒是否就是对性能的一个极大的开销？（答案是是的，这个情况被称为thundering herd）\n\n## 解决途径\n\n在讨论问题前需要说明的是，在epoll的文档中，作者用比较暧昧的口气说epoll的几个内置函数都是线程安全的（个人感觉），但是暂时也没时间把它代码读了，所以只好以此为基础来做后面的实现了。\n\n在读了两篇博文，上网查阅了Linux的资料后，终于解决了基础的问题，答案就是在在Linux2.6.2中新增的EPOLLONESHOT和Linux4.5中新增的EPOLLEXCLUSIVE。\n\n前者想解决的是这样的问题：\n\n一个文件描述符可能被多个epoll_wait()拉出来，那么就会出现一个竞争的问题。将事件的属性或上EPOLLONESHOT就可以让它被一个epoll_wait()拉出来以后在内部被禁用。\n\n后者想解决的则是thundering herd问题：\n\n如果实例被制定了EPOLLEXCLUSIVE，它们发生事件的时候会只向一个epoll file decriptor发出通知，于是就可以让那个对应的线程接受到事件。\n\n了解了上面两个标示后，将给出目前的做法和之后优化的思路。\n\n## 目前思路\n\n{% asset_img flowchart.png flowchart %}\n\n我使用了单个epoll file descritptor，每个线程维护自己的epoll_evets数组的方法。每个socket加入epoll的时候，都设置EPOLLONESHOT和EPOLLEXCLUSIVE解决竞争问题。\n\n我采用了单独开了100线程（后来测试发现，处理读写的线程效率比我想象的还要低，改成了10）用于不断创建socket并完成连接、写数据、将其加入的过程，因为这个实现方式完成读写的效率实在过于低下，只需开这么几个线程建立的连接就可以处理完了，因为这样，这样的实现方式concurrent number只能作为一个上限，测试过程中能有一两秒能达到10000就不错了……\n\n以及连接总数比较高的时候，会出现\n\n{% asset_img snipaste20180320_005219.png problem %}\n\n具体原因不明，还在排查中，多线程单连接没出现过这种问题。\n\n## 优化思路\n\n开profile tools正在跑，准备看看哪些调用耗时较大。\n\n另外从博客中还看到一种新的结构，应该就能实现一个性能不错的压力测试软件了。\n\n就是开一些线程创建socket连接，用单个线程将epoll_event依次加入一个队列里，处理线程分别向队列里取事件并处理，也就是供应商和客户这个多线程模型。\n\n这样做的话有这样的问题：\n\n- 代码复杂度上升。\n  - 要实现一个高效的队列，那么可以否决不断malloc/free的做法，而是开辟一块内存固定用来放这个队列，同时应该申请锁或者用信号来避免竞争时间。\n  - 因为是有事件才交给线程处理，所以会有一个线程的不断创建与消亡的代价，这个开销也是很大的，目前了解到的高效的做法是用线程池来提升效率。\n- 没有解决目前的BUG\n  - 还没了解具体原因，如果是基于错误程序做的优化，依然可能产生同样的错误\n- socket连接创建加入的操作\n  - socket的连接以及加入epoll是由另一些进程处理的，要协同好它们的关系还需要进一步的考虑，这里只能说做了一个比较粗糙的设想，暂时还没有想到/找到更好、更合适的做法。\n\n\n\n\n# 0x2 源代码\n\n``` c\n#include <stdio.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <string.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/epoll.h>\n#include <asm/errno.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <assert.h>\n\n#define WAIT_COUNT_MAX 3\n#define SOCK_LIST_COUNT 40960\n\n#define EPOLLINEV (EPOLLIN | EPOLLET | EPOLLONESHOT | EPOLLEXCLUSIVE)\n\ntypedef int file_descriptor;\n\nchar response[1024];\nstatic int g_total = 0;\nstatic int g_max_total = 0;\nstatic int g_con = 0;\nstatic int g_request_count = 0;\nstatic int g_complete = 0;\nstatic int g_max_con = 0;\nstatic int request_lenth;\nstatic int thread_count;\npthread_t g_print_thread;\nfile_descriptor epfd;\n\nstatic const int port = 80;\nstruct hostent *server;\nstruct sockaddr_in serverAddr;\nstatic char request[1024];\n\nvoid *print_condition(void *arg){\n    struct timeval cur_time;\n    int index = 0;\n    fprintf(stdout, \"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\ttotla_requests\\n\");\n    while(g_total < g_max_total) {\n        sleep(1);\n        gettimeofday(&cur_time, NULL);\n        fprintf(stdout, \"%5d\\t%21ld\\t%25d\\t%16d\\t%14d\\n\",index, cur_time.tv_sec*1000000 + cur_time.tv_usec, g_con, g_total, g_request_count);\n        __sync_and_and_fetch(&g_con, 0);\n        ++index;\n    }\n}\n\nint init_print_thread(){\n    return pthread_create(&g_print_thread, NULL, print_condition, NULL);\n}\n\nint make_socket(){\n    file_descriptor sock;\n\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if(sock < 0){\n        perror(\"Create socket error\");\n        exit(EXIT_FAILURE);\n    }\n\n    return sock;\n}\n\nvoid connect_server(file_descriptor sock){\n    if(connect(sock, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0){\n        perror(\"Connect server error\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint is_nonblock(int fd, int fflag) {\n    int flags = fcntl(fd, F_GETFL);\n    if (flags == -1) {\n        char *s = fflag ?\"read\":\"write\";\n        perror(s);\n        exit(EXIT_FAILURE);\n    }\n    return (flags & O_NONBLOCK) ? 1 : 0;\n}\n\nvoid set_nonblock(file_descriptor fd) {\n    int flags = fcntl(fd, F_GETFL);\n    if (flags == -1) {\n        perror(\"get fd flags error\");\n        exit(EXIT_FAILURE);\n    }\n    flags |= O_NONBLOCK;\n    flags = fcntl(fd, F_SETFL, flags);\n    if (flags == -1) {\n        perror(\"set fd flags error\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint socket_write(file_descriptor sock){\n    int nbytes;\n    int wait_count = 0;\n    int send_suc = 1;\n    while (1) {\n        nbytes = send(sock, request, request_lenth, 0);\n\n        if (nbytes < 0) {\n            if (is_nonblock(sock, 0)) {\n                if (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno) {\n                    if (wait_count < WAIT_COUNT_MAX) {\n                        ++wait_count;\n                        usleep(wait_count);\n                        continue;\n                    }\n                }\n            }\n            break;\n        } else if (nbytes == 0) {\n            break;\n        } else if(nbytes == request_lenth){\n            send_suc = 0;\n            break;\n        }\n    }\n\n    return send_suc;\n}\n\nint socket_read(file_descriptor sock){\n    int nbytes;\n    int wait_count = 0;\n    int recv_suc = 1;\n    while (1) {\n        nbytes = recv(sock, response, sizeof(response) - 1, 0);\n        if (nbytes < 0) {\n            if (is_nonblock(sock, 1)) {\n                if (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno) {\n                    if (wait_count < WAIT_COUNT_MAX) {\n                        wait_count++;\n                        usleep(wait_count);\n                        continue;\n                    }\n                }\n            }\n            break;\n        }\n        if (nbytes == 0) {\n            break;\n        } else if (nbytes > 0) {\n            recv_suc = 0;\n        }\n    }\n    return recv_suc;\n}\n\nvoid make_connection(file_descriptor epfd){\n    struct epoll_event ev;\n    file_descriptor socket;\n    socket = make_socket();\n    connect_server(socket);\n    set_nonblock(socket);\n\n    ev.data.fd = socket;\n    socket_write(socket);\n    ev.events = EPOLLINEV;\n    epoll_ctl(epfd, EPOLL_CTL_ADD, socket, &ev);\n\n    __sync_fetch_and_add(&g_request_count, 1);\n}\n\nvoid *connect_thread(void *args){\n    while (__sync_fetch_and_add(&g_total, 1) < g_max_total){\n        if (__sync_fetch_and_add(&g_con, 1) < g_max_con){\n            make_connection(epfd);\n        } else {\n            __sync_fetch_and_add(&g_con, -1);\n            __sync_fetch_and_add(&g_total, -1);\n        }\n    }\n}\n\nvoid *thread_connetion(void *arg){\n    file_descriptor nfds;\n    int index;\n    struct epoll_event events[SOCK_LIST_COUNT];\n\n    while (1){\n        usleep(50);\n        nfds = epoll_wait(epfd, events, sizeof(events), 500);\n        for(index = 0; index < nfds; ++index){\n            file_descriptor fd = events[index].data.fd;\n            if(events[index].events & EPOLLIN){\n                if (!socket_read(fd)){\n                    epoll_ctl(epfd, EPOLL_CTL_DEL, fd, events);\n                    close(fd);\n                }\n            }\n        }\n    }\n\n}\n\nint init_server(const char *host){\n    server = gethostbyname(host);\n    if(server == NULL){\n        return -1;\n    }\n\n\tsprintf(request,\"GET  HTTP/1.1\\r\\n\"\n        \"Host: %s\\r\\n\"\n        \"Connection: keep-alive\\r\\n\"\n        \"Cache-Control: max-age=0\\r\\n\"\n        \"Upgrade-Insecure-Requests: 1\\r\\n\"\n        \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"\n        \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"\n        \"Accept-Encoding: gzip, deflate\\r\\n\"\n        \"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\",host);\n    request_lenth = strlen(request);\n\n    bzero(&serverAddr, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    memcpy(&serverAddr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n    return 0;\n}\n\nvoid usage(char *name){\n    printf(\"Usage: %s [thread_count] [concurrent_connections] [total_connection] [hostname]\\n\"\n                   \"Due to limitation of number of file descriptor,\\n\"\n                   \"connection per thread should not be too large.\\n\", name);\n}\n\nint main(int argc, char **argv) {\n    int err;\n    pthread_t thread_id;\n    int index;\n\n    if(argc != 5){\n        usage(argv[0]);\n        exit(EXIT_SUCCESS);\n    }\n\n    thread_count = atoi(argv[1]);\n    g_max_con = atoi(argv[2]);\n    g_max_total = atoi(argv[3]);\n\n    assert(thread_count > 0);\n    assert(g_max_con > 0);\n    assert(g_max_total > 0);\n\n    err = init_print_thread();\n    if(err < 0){\n        perror(\"Create print thread error\");\n        exit(EXIT_FAILURE);\n    }\n\n    epfd = epoll_create1(0);\n\n    err = init_server(argv[4]);\n    if(err < 0){\n        perror(\"No such host\");\n    }\n\n    for (index = 0; index < thread_count/10; ++index){\n        err = pthread_create(&thread_id, NULL, connect_thread, NULL);\n        if(err < 0){\n            perror(\"Create print thread error\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n\n    for (index = 0; index < thread_count; ++index){\n        err = pthread_create(&thread_id, NULL, thread_connetion, NULL);\n        if(err < 0){\n            perror(\"Create print thread error\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    pthread_join(g_print_thread, NULL);\n    exit(EXIT_SUCCESS);\n}\n```\n\n","source":"_posts/完成一个C语言http服务器压力测试工具（三）.md","raw":"---\ntitle: 完成一个C语言http服务器压力测试工具（三）\nconnments: true\ndate: 2018-03-19 22:09:47\ntags: \n\t- C\n\t- Software Development\ncategories: Notes\ndesc: 完成一个C语言http服务器压力测试工具（三）\nsummary: 复习加深入了解的机会~\n---\n\n# 0x0 学习资料\n\n- 《UNIX网络编程 卷1：套接字API（第三版）》\n- 《Linux/UNIX系统编程手册》\n- [Epoll is fundamentally broken 1/2](https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/)\n- [Epoll is fundamentally broken 2/2](https://idea.popcount.org/2017-03-20-epoll-is-fundamentally-broken-22/)\n\n# 0x1 学习路途\n\n这次东西深入的比较多，所以先在前面尝试叙述一下学到的一点东西，然后从知识的基础上再来写程序。\n\n## 非阻塞I/O\n\n在上次实现的两个程序中，采用的都是阻塞型I/O模型，所谓阻塞性I/O模型就是指单个线程每次只在一个文件描述符上进行I/O操作（在本例中是一个socket），每次I/O系统调用都会一直阻塞直到完成数据传输，那么只需要出现以下这些情况，那么情况就会变得很麻烦：\n\n- 检查文件描述符上是否需要进行I/O\n- 对没有数据到来的socket调用了read()方法\n- 需要检查多个文件描述符，查看他们是否可执行I/O\n\n一旦阻塞上，只能等待操作完成才能进行下一步的操作，这对于许多追求效率的场合都是不能忍受的。于是目前的操作系统都引入了非阻塞I/O的方法。pipe、FIFO、socket、设备都支持非阻塞模式，除了open()外，对于socket、pipe这种无法通过open()获取文件描述符的文件来说，可以使用fcntl()的F_SETFL命令启用非阻塞标志。\n\n除此之外，对于我们所要使用的socket来说，可以在socket()函数的第二个参数中或上SOCK_NONBLOCK来使得socket变成非阻塞模式，需要注意的是，非阻塞模式的socket在进行connect()的时候会返回负值，并将errno置为EINPROGRESS。\n\n## I/O多路复用\n\n有了非阻塞I/O模型，那么我们就可以这样提升我们的效率：\n\n首先对目前有的文件描述符做一个检查，查看是否有可以执行I/O的文件描述符，然后对这些文件描述符执行I/O操作（例如这时可以为这个I/O新开一个线程/进程），这样我们的效率就提升上来了。\n\n但是显然不应该对已有的文件描述符形成的集合进行不停的遍历，这样效率会被浪费许多，好在Linux提供了一些I/O多路复用的接口，包括select/poll/epoll(Linux 2.6+)\n\n做一个粗略的比较的话，如果限定在Linux平台上，那么epoll无疑是最好的选择，原因有以下几个：\n\n- 文件描述符范围有限制。select底层用数组实现，最大连接数写死\n- 时间复杂度为O(n)。select/poll在获得事件数后，都需要进行遍历来确认。\n- 文件描述符拷贝。每次调用select/poll的时候，都会有一次拷贝。\n\nselect/poll/epoll作为三个比较成熟的I/O复用模型，还有很多值得说的东西，但介于一个自己能力不够，另一个时间太少，没法在这里展开叙述了。\n\n## 多线程I/O复用\n\n多线程使用epoll的时候，就需要考虑以下问题：\n\n- 各线程的epoll是否是同一个？\n  - 如果是的话，如何保证调用epoll_wait()获得的event是独立的\n  - 如果不是的话，建立连接的线程该向哪个epoll file descriptor添加\n- 各线程的epoll_event是否是同一个？\n  - 如果是的话，如何保证他们处理的event是互斥的\n  - 如果不是的话，如何保证他们分别的epoll_event交际是空的\n- 如何保证各线程处理的socket没有交集？\n\n以及有关性能的其他考虑：\n\n- 考虑这样的情况，如果多个处理连接的线程都闲置了，此时突然来了一个I/O请求，会不会发生多线程的争抢？或者单纯多个线程的唤醒是否就是对性能的一个极大的开销？（答案是是的，这个情况被称为thundering herd）\n\n## 解决途径\n\n在讨论问题前需要说明的是，在epoll的文档中，作者用比较暧昧的口气说epoll的几个内置函数都是线程安全的（个人感觉），但是暂时也没时间把它代码读了，所以只好以此为基础来做后面的实现了。\n\n在读了两篇博文，上网查阅了Linux的资料后，终于解决了基础的问题，答案就是在在Linux2.6.2中新增的EPOLLONESHOT和Linux4.5中新增的EPOLLEXCLUSIVE。\n\n前者想解决的是这样的问题：\n\n一个文件描述符可能被多个epoll_wait()拉出来，那么就会出现一个竞争的问题。将事件的属性或上EPOLLONESHOT就可以让它被一个epoll_wait()拉出来以后在内部被禁用。\n\n后者想解决的则是thundering herd问题：\n\n如果实例被制定了EPOLLEXCLUSIVE，它们发生事件的时候会只向一个epoll file decriptor发出通知，于是就可以让那个对应的线程接受到事件。\n\n了解了上面两个标示后，将给出目前的做法和之后优化的思路。\n\n## 目前思路\n\n{% asset_img flowchart.png flowchart %}\n\n我使用了单个epoll file descritptor，每个线程维护自己的epoll_evets数组的方法。每个socket加入epoll的时候，都设置EPOLLONESHOT和EPOLLEXCLUSIVE解决竞争问题。\n\n我采用了单独开了100线程（后来测试发现，处理读写的线程效率比我想象的还要低，改成了10）用于不断创建socket并完成连接、写数据、将其加入的过程，因为这个实现方式完成读写的效率实在过于低下，只需开这么几个线程建立的连接就可以处理完了，因为这样，这样的实现方式concurrent number只能作为一个上限，测试过程中能有一两秒能达到10000就不错了……\n\n以及连接总数比较高的时候，会出现\n\n{% asset_img snipaste20180320_005219.png problem %}\n\n具体原因不明，还在排查中，多线程单连接没出现过这种问题。\n\n## 优化思路\n\n开profile tools正在跑，准备看看哪些调用耗时较大。\n\n另外从博客中还看到一种新的结构，应该就能实现一个性能不错的压力测试软件了。\n\n就是开一些线程创建socket连接，用单个线程将epoll_event依次加入一个队列里，处理线程分别向队列里取事件并处理，也就是供应商和客户这个多线程模型。\n\n这样做的话有这样的问题：\n\n- 代码复杂度上升。\n  - 要实现一个高效的队列，那么可以否决不断malloc/free的做法，而是开辟一块内存固定用来放这个队列，同时应该申请锁或者用信号来避免竞争时间。\n  - 因为是有事件才交给线程处理，所以会有一个线程的不断创建与消亡的代价，这个开销也是很大的，目前了解到的高效的做法是用线程池来提升效率。\n- 没有解决目前的BUG\n  - 还没了解具体原因，如果是基于错误程序做的优化，依然可能产生同样的错误\n- socket连接创建加入的操作\n  - socket的连接以及加入epoll是由另一些进程处理的，要协同好它们的关系还需要进一步的考虑，这里只能说做了一个比较粗糙的设想，暂时还没有想到/找到更好、更合适的做法。\n\n\n\n\n# 0x2 源代码\n\n``` c\n#include <stdio.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <string.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/epoll.h>\n#include <asm/errno.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <assert.h>\n\n#define WAIT_COUNT_MAX 3\n#define SOCK_LIST_COUNT 40960\n\n#define EPOLLINEV (EPOLLIN | EPOLLET | EPOLLONESHOT | EPOLLEXCLUSIVE)\n\ntypedef int file_descriptor;\n\nchar response[1024];\nstatic int g_total = 0;\nstatic int g_max_total = 0;\nstatic int g_con = 0;\nstatic int g_request_count = 0;\nstatic int g_complete = 0;\nstatic int g_max_con = 0;\nstatic int request_lenth;\nstatic int thread_count;\npthread_t g_print_thread;\nfile_descriptor epfd;\n\nstatic const int port = 80;\nstruct hostent *server;\nstruct sockaddr_in serverAddr;\nstatic char request[1024];\n\nvoid *print_condition(void *arg){\n    struct timeval cur_time;\n    int index = 0;\n    fprintf(stdout, \"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\ttotla_requests\\n\");\n    while(g_total < g_max_total) {\n        sleep(1);\n        gettimeofday(&cur_time, NULL);\n        fprintf(stdout, \"%5d\\t%21ld\\t%25d\\t%16d\\t%14d\\n\",index, cur_time.tv_sec*1000000 + cur_time.tv_usec, g_con, g_total, g_request_count);\n        __sync_and_and_fetch(&g_con, 0);\n        ++index;\n    }\n}\n\nint init_print_thread(){\n    return pthread_create(&g_print_thread, NULL, print_condition, NULL);\n}\n\nint make_socket(){\n    file_descriptor sock;\n\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if(sock < 0){\n        perror(\"Create socket error\");\n        exit(EXIT_FAILURE);\n    }\n\n    return sock;\n}\n\nvoid connect_server(file_descriptor sock){\n    if(connect(sock, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0){\n        perror(\"Connect server error\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint is_nonblock(int fd, int fflag) {\n    int flags = fcntl(fd, F_GETFL);\n    if (flags == -1) {\n        char *s = fflag ?\"read\":\"write\";\n        perror(s);\n        exit(EXIT_FAILURE);\n    }\n    return (flags & O_NONBLOCK) ? 1 : 0;\n}\n\nvoid set_nonblock(file_descriptor fd) {\n    int flags = fcntl(fd, F_GETFL);\n    if (flags == -1) {\n        perror(\"get fd flags error\");\n        exit(EXIT_FAILURE);\n    }\n    flags |= O_NONBLOCK;\n    flags = fcntl(fd, F_SETFL, flags);\n    if (flags == -1) {\n        perror(\"set fd flags error\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint socket_write(file_descriptor sock){\n    int nbytes;\n    int wait_count = 0;\n    int send_suc = 1;\n    while (1) {\n        nbytes = send(sock, request, request_lenth, 0);\n\n        if (nbytes < 0) {\n            if (is_nonblock(sock, 0)) {\n                if (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno) {\n                    if (wait_count < WAIT_COUNT_MAX) {\n                        ++wait_count;\n                        usleep(wait_count);\n                        continue;\n                    }\n                }\n            }\n            break;\n        } else if (nbytes == 0) {\n            break;\n        } else if(nbytes == request_lenth){\n            send_suc = 0;\n            break;\n        }\n    }\n\n    return send_suc;\n}\n\nint socket_read(file_descriptor sock){\n    int nbytes;\n    int wait_count = 0;\n    int recv_suc = 1;\n    while (1) {\n        nbytes = recv(sock, response, sizeof(response) - 1, 0);\n        if (nbytes < 0) {\n            if (is_nonblock(sock, 1)) {\n                if (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno) {\n                    if (wait_count < WAIT_COUNT_MAX) {\n                        wait_count++;\n                        usleep(wait_count);\n                        continue;\n                    }\n                }\n            }\n            break;\n        }\n        if (nbytes == 0) {\n            break;\n        } else if (nbytes > 0) {\n            recv_suc = 0;\n        }\n    }\n    return recv_suc;\n}\n\nvoid make_connection(file_descriptor epfd){\n    struct epoll_event ev;\n    file_descriptor socket;\n    socket = make_socket();\n    connect_server(socket);\n    set_nonblock(socket);\n\n    ev.data.fd = socket;\n    socket_write(socket);\n    ev.events = EPOLLINEV;\n    epoll_ctl(epfd, EPOLL_CTL_ADD, socket, &ev);\n\n    __sync_fetch_and_add(&g_request_count, 1);\n}\n\nvoid *connect_thread(void *args){\n    while (__sync_fetch_and_add(&g_total, 1) < g_max_total){\n        if (__sync_fetch_and_add(&g_con, 1) < g_max_con){\n            make_connection(epfd);\n        } else {\n            __sync_fetch_and_add(&g_con, -1);\n            __sync_fetch_and_add(&g_total, -1);\n        }\n    }\n}\n\nvoid *thread_connetion(void *arg){\n    file_descriptor nfds;\n    int index;\n    struct epoll_event events[SOCK_LIST_COUNT];\n\n    while (1){\n        usleep(50);\n        nfds = epoll_wait(epfd, events, sizeof(events), 500);\n        for(index = 0; index < nfds; ++index){\n            file_descriptor fd = events[index].data.fd;\n            if(events[index].events & EPOLLIN){\n                if (!socket_read(fd)){\n                    epoll_ctl(epfd, EPOLL_CTL_DEL, fd, events);\n                    close(fd);\n                }\n            }\n        }\n    }\n\n}\n\nint init_server(const char *host){\n    server = gethostbyname(host);\n    if(server == NULL){\n        return -1;\n    }\n\n\tsprintf(request,\"GET  HTTP/1.1\\r\\n\"\n        \"Host: %s\\r\\n\"\n        \"Connection: keep-alive\\r\\n\"\n        \"Cache-Control: max-age=0\\r\\n\"\n        \"Upgrade-Insecure-Requests: 1\\r\\n\"\n        \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"\n        \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"\n        \"Accept-Encoding: gzip, deflate\\r\\n\"\n        \"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\",host);\n    request_lenth = strlen(request);\n\n    bzero(&serverAddr, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    memcpy(&serverAddr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n    return 0;\n}\n\nvoid usage(char *name){\n    printf(\"Usage: %s [thread_count] [concurrent_connections] [total_connection] [hostname]\\n\"\n                   \"Due to limitation of number of file descriptor,\\n\"\n                   \"connection per thread should not be too large.\\n\", name);\n}\n\nint main(int argc, char **argv) {\n    int err;\n    pthread_t thread_id;\n    int index;\n\n    if(argc != 5){\n        usage(argv[0]);\n        exit(EXIT_SUCCESS);\n    }\n\n    thread_count = atoi(argv[1]);\n    g_max_con = atoi(argv[2]);\n    g_max_total = atoi(argv[3]);\n\n    assert(thread_count > 0);\n    assert(g_max_con > 0);\n    assert(g_max_total > 0);\n\n    err = init_print_thread();\n    if(err < 0){\n        perror(\"Create print thread error\");\n        exit(EXIT_FAILURE);\n    }\n\n    epfd = epoll_create1(0);\n\n    err = init_server(argv[4]);\n    if(err < 0){\n        perror(\"No such host\");\n    }\n\n    for (index = 0; index < thread_count/10; ++index){\n        err = pthread_create(&thread_id, NULL, connect_thread, NULL);\n        if(err < 0){\n            perror(\"Create print thread error\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n\n    for (index = 0; index < thread_count; ++index){\n        err = pthread_create(&thread_id, NULL, thread_connetion, NULL);\n        if(err < 0){\n            perror(\"Create print thread error\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    pthread_join(g_print_thread, NULL);\n    exit(EXIT_SUCCESS);\n}\n```\n\n","slug":"完成一个C语言http服务器压力测试工具（三）","published":1,"updated":"2018-04-08T07:13:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgqnsczq000adkudjsnni7j1","content":"<h1 id=\"0x0-学习资料\"><a href=\"#0x0-学习资料\" class=\"headerlink\" title=\"0x0 学习资料\"></a>0x0 学习资料</h1><ul>\n<li>《UNIX网络编程 卷1：套接字API（第三版）》</li>\n<li>《Linux/UNIX系统编程手册》</li>\n<li><a href=\"https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/\" target=\"_blank\" rel=\"noopener\">Epoll is fundamentally broken 1/2</a></li>\n<li><a href=\"https://idea.popcount.org/2017-03-20-epoll-is-fundamentally-broken-22/\" target=\"_blank\" rel=\"noopener\">Epoll is fundamentally broken 2/2</a></li>\n</ul>\n<h1 id=\"0x1-学习路途\"><a href=\"#0x1-学习路途\" class=\"headerlink\" title=\"0x1 学习路途\"></a>0x1 学习路途</h1><p>这次东西深入的比较多，所以先在前面尝试叙述一下学到的一点东西，然后从知识的基础上再来写程序。</p>\n<h2 id=\"非阻塞I-O\"><a href=\"#非阻塞I-O\" class=\"headerlink\" title=\"非阻塞I/O\"></a>非阻塞I/O</h2><p>在上次实现的两个程序中，采用的都是阻塞型I/O模型，所谓阻塞性I/O模型就是指单个线程每次只在一个文件描述符上进行I/O操作（在本例中是一个socket），每次I/O系统调用都会一直阻塞直到完成数据传输，那么只需要出现以下这些情况，那么情况就会变得很麻烦：</p>\n<ul>\n<li>检查文件描述符上是否需要进行I/O</li>\n<li>对没有数据到来的socket调用了read()方法</li>\n<li>需要检查多个文件描述符，查看他们是否可执行I/O</li>\n</ul>\n<p>一旦阻塞上，只能等待操作完成才能进行下一步的操作，这对于许多追求效率的场合都是不能忍受的。于是目前的操作系统都引入了非阻塞I/O的方法。pipe、FIFO、socket、设备都支持非阻塞模式，除了open()外，对于socket、pipe这种无法通过open()获取文件描述符的文件来说，可以使用fcntl()的F_SETFL命令启用非阻塞标志。</p>\n<p>除此之外，对于我们所要使用的socket来说，可以在socket()函数的第二个参数中或上SOCK_NONBLOCK来使得socket变成非阻塞模式，需要注意的是，非阻塞模式的socket在进行connect()的时候会返回负值，并将errno置为EINPROGRESS。</p>\n<h2 id=\"I-O多路复用\"><a href=\"#I-O多路复用\" class=\"headerlink\" title=\"I/O多路复用\"></a>I/O多路复用</h2><p>有了非阻塞I/O模型，那么我们就可以这样提升我们的效率：</p>\n<p>首先对目前有的文件描述符做一个检查，查看是否有可以执行I/O的文件描述符，然后对这些文件描述符执行I/O操作（例如这时可以为这个I/O新开一个线程/进程），这样我们的效率就提升上来了。</p>\n<p>但是显然不应该对已有的文件描述符形成的集合进行不停的遍历，这样效率会被浪费许多，好在Linux提供了一些I/O多路复用的接口，包括select/poll/epoll(Linux 2.6+)</p>\n<p>做一个粗略的比较的话，如果限定在Linux平台上，那么epoll无疑是最好的选择，原因有以下几个：</p>\n<ul>\n<li>文件描述符范围有限制。select底层用数组实现，最大连接数写死</li>\n<li>时间复杂度为O(n)。select/poll在获得事件数后，都需要进行遍历来确认。</li>\n<li>文件描述符拷贝。每次调用select/poll的时候，都会有一次拷贝。</li>\n</ul>\n<p>select/poll/epoll作为三个比较成熟的I/O复用模型，还有很多值得说的东西，但介于一个自己能力不够，另一个时间太少，没法在这里展开叙述了。</p>\n<h2 id=\"多线程I-O复用\"><a href=\"#多线程I-O复用\" class=\"headerlink\" title=\"多线程I/O复用\"></a>多线程I/O复用</h2><p>多线程使用epoll的时候，就需要考虑以下问题：</p>\n<ul>\n<li>各线程的epoll是否是同一个？<ul>\n<li>如果是的话，如何保证调用epoll_wait()获得的event是独立的</li>\n<li>如果不是的话，建立连接的线程该向哪个epoll file descriptor添加</li>\n</ul>\n</li>\n<li>各线程的epoll_event是否是同一个？<ul>\n<li>如果是的话，如何保证他们处理的event是互斥的</li>\n<li>如果不是的话，如何保证他们分别的epoll_event交际是空的</li>\n</ul>\n</li>\n<li>如何保证各线程处理的socket没有交集？</li>\n</ul>\n<p>以及有关性能的其他考虑：</p>\n<ul>\n<li>考虑这样的情况，如果多个处理连接的线程都闲置了，此时突然来了一个I/O请求，会不会发生多线程的争抢？或者单纯多个线程的唤醒是否就是对性能的一个极大的开销？（答案是是的，这个情况被称为thundering herd）</li>\n</ul>\n<h2 id=\"解决途径\"><a href=\"#解决途径\" class=\"headerlink\" title=\"解决途径\"></a>解决途径</h2><p>在讨论问题前需要说明的是，在epoll的文档中，作者用比较暧昧的口气说epoll的几个内置函数都是线程安全的（个人感觉），但是暂时也没时间把它代码读了，所以只好以此为基础来做后面的实现了。</p>\n<p>在读了两篇博文，上网查阅了Linux的资料后，终于解决了基础的问题，答案就是在在Linux2.6.2中新增的EPOLLONESHOT和Linux4.5中新增的EPOLLEXCLUSIVE。</p>\n<p>前者想解决的是这样的问题：</p>\n<p>一个文件描述符可能被多个epoll_wait()拉出来，那么就会出现一个竞争的问题。将事件的属性或上EPOLLONESHOT就可以让它被一个epoll_wait()拉出来以后在内部被禁用。</p>\n<p>后者想解决的则是thundering herd问题：</p>\n<p>如果实例被制定了EPOLLEXCLUSIVE，它们发生事件的时候会只向一个epoll file decriptor发出通知，于是就可以让那个对应的线程接受到事件。</p>\n<p>了解了上面两个标示后，将给出目前的做法和之后优化的思路。</p>\n<h2 id=\"目前思路\"><a href=\"#目前思路\" class=\"headerlink\" title=\"目前思路\"></a>目前思路</h2><img src=\"/2018/03/19/完成一个C语言http服务器压力测试工具（三）/flowchart.png\" title=\"flowchart\">\n<p>我使用了单个epoll file descritptor，每个线程维护自己的epoll_evets数组的方法。每个socket加入epoll的时候，都设置EPOLLONESHOT和EPOLLEXCLUSIVE解决竞争问题。</p>\n<p>我采用了单独开了100线程（后来测试发现，处理读写的线程效率比我想象的还要低，改成了10）用于不断创建socket并完成连接、写数据、将其加入的过程，因为这个实现方式完成读写的效率实在过于低下，只需开这么几个线程建立的连接就可以处理完了，因为这样，这样的实现方式concurrent number只能作为一个上限，测试过程中能有一两秒能达到10000就不错了……</p>\n<p>以及连接总数比较高的时候，会出现</p>\n<img src=\"/2018/03/19/完成一个C语言http服务器压力测试工具（三）/snipaste20180320_005219.png\" title=\"problem\">\n<p>具体原因不明，还在排查中，多线程单连接没出现过这种问题。</p>\n<h2 id=\"优化思路\"><a href=\"#优化思路\" class=\"headerlink\" title=\"优化思路\"></a>优化思路</h2><p>开profile tools正在跑，准备看看哪些调用耗时较大。</p>\n<p>另外从博客中还看到一种新的结构，应该就能实现一个性能不错的压力测试软件了。</p>\n<p>就是开一些线程创建socket连接，用单个线程将epoll_event依次加入一个队列里，处理线程分别向队列里取事件并处理，也就是供应商和客户这个多线程模型。</p>\n<p>这样做的话有这样的问题：</p>\n<ul>\n<li>代码复杂度上升。<ul>\n<li>要实现一个高效的队列，那么可以否决不断malloc/free的做法，而是开辟一块内存固定用来放这个队列，同时应该申请锁或者用信号来避免竞争时间。</li>\n<li>因为是有事件才交给线程处理，所以会有一个线程的不断创建与消亡的代价，这个开销也是很大的，目前了解到的高效的做法是用线程池来提升效率。</li>\n</ul>\n</li>\n<li>没有解决目前的BUG<ul>\n<li>还没了解具体原因，如果是基于错误程序做的优化，依然可能产生同样的错误</li>\n</ul>\n</li>\n<li>socket连接创建加入的操作<ul>\n<li>socket的连接以及加入epoll是由另一些进程处理的，要协同好它们的关系还需要进一步的考虑，这里只能说做了一个比较粗糙的设想，暂时还没有想到/找到更好、更合适的做法。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"0x2-源代码\"><a href=\"#0x2-源代码\" class=\"headerlink\" title=\"0x2 源代码\"></a>0x2 源代码</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/epoll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;asm/errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WAIT_COUNT_MAX 3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCK_LIST_COUNT 40960</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> EPOLLINEV (EPOLLIN | EPOLLET | EPOLLONESHOT | EPOLLEXCLUSIVE)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> file_descriptor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> response[<span class=\"number\">1024</span>];</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_total = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_max_total = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_con = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_request_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_complete = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_max_con = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> request_lenth;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> thread_count;</span><br><span class=\"line\"><span class=\"keyword\">pthread_t</span> g_print_thread;</span><br><span class=\"line\">file_descriptor epfd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port = <span class=\"number\">80</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">server</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> request[<span class=\"number\">1024</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">print_condition</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">cur_time</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\ttotla_requests\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(g_total &lt; g_max_total) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        gettimeofday(&amp;cur_time, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"%5d\\t%21ld\\t%25d\\t%16d\\t%14d\\n\"</span>,index, cur_time.tv_sec*<span class=\"number\">1000000</span> + cur_time.tv_usec, g_con, g_total, g_request_count);</span><br><span class=\"line\">        __sync_and_and_fetch(&amp;g_con, <span class=\"number\">0</span>);</span><br><span class=\"line\">        ++index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_print_thread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_create(&amp;g_print_thread, <span class=\"literal\">NULL</span>, print_condition, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">make_socket</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    file_descriptor sock;</span><br><span class=\"line\"></span><br><span class=\"line\">    sock = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sock &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Create socket error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sock;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connect_server</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(connect(sock, (struct sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr)) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Connect server error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_nonblock</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> fflag)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *s = fflag ?<span class=\"string\">\"read\"</span>:<span class=\"string\">\"write\"</span>;</span><br><span class=\"line\">        perror(s);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (flags &amp; O_NONBLOCK) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_nonblock</span><span class=\"params\">(file_descriptor fd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"get fd flags error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    flags |= O_NONBLOCK;</span><br><span class=\"line\">    flags = fcntl(fd, F_SETFL, flags);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"set fd flags error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket_write</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nbytes;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wait_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> send_suc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        nbytes = send(sock, request, request_lenth, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is_nonblock(sock, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (wait_count &lt; WAIT_COUNT_MAX) &#123;</span><br><span class=\"line\">                        ++wait_count;</span><br><span class=\"line\">                        usleep(wait_count);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nbytes == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nbytes == request_lenth)&#123;</span><br><span class=\"line\">            send_suc = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> send_suc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket_read</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nbytes;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wait_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> recv_suc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        nbytes = recv(sock, response, <span class=\"keyword\">sizeof</span>(response) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is_nonblock(sock, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (wait_count &lt; WAIT_COUNT_MAX) &#123;</span><br><span class=\"line\">                        wait_count++;</span><br><span class=\"line\">                        usleep(wait_count);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nbytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            recv_suc = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> recv_suc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_connection</span><span class=\"params\">(file_descriptor epfd)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">ev</span>;</span></span><br><span class=\"line\">    file_descriptor socket;</span><br><span class=\"line\">    socket = make_socket();</span><br><span class=\"line\">    connect_server(socket);</span><br><span class=\"line\">    set_nonblock(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    ev.data.fd = socket;</span><br><span class=\"line\">    socket_write(socket);</span><br><span class=\"line\">    ev.events = EPOLLINEV;</span><br><span class=\"line\">    epoll_ctl(epfd, EPOLL_CTL_ADD, socket, &amp;ev);</span><br><span class=\"line\"></span><br><span class=\"line\">    __sync_fetch_and_add(&amp;g_request_count, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">connect_thread</span><span class=\"params\">(<span class=\"keyword\">void</span> *args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (__sync_fetch_and_add(&amp;g_total, <span class=\"number\">1</span>) &lt; g_max_total)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__sync_fetch_and_add(&amp;g_con, <span class=\"number\">1</span>) &lt; g_max_con)&#123;</span><br><span class=\"line\">            make_connection(epfd);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            __sync_fetch_and_add(&amp;g_con, <span class=\"number\">-1</span>);</span><br><span class=\"line\">            __sync_fetch_and_add(&amp;g_total, <span class=\"number\">-1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">thread_connetion</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    file_descriptor nfds;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">events</span>[<span class=\"title\">SOCK_LIST_COUNT</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        usleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">        nfds = epoll_wait(epfd, events, <span class=\"keyword\">sizeof</span>(events), <span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(index = <span class=\"number\">0</span>; index &lt; nfds; ++index)&#123;</span><br><span class=\"line\">            file_descriptor fd = events[index].data.fd;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(events[index].events &amp; EPOLLIN)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!socket_read(fd))&#123;</span><br><span class=\"line\">                    epoll_ctl(epfd, EPOLL_CTL_DEL, fd, events);</span><br><span class=\"line\">                    close(fd);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_server</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *host)</span></span>&#123;</span><br><span class=\"line\">    server = gethostbyname(host);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(server == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sprintf</span>(request,<span class=\"string\">\"GET  HTTP/1.1\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Host: %s\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Connection: keep-alive\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Cache-Control: max-age=0\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Upgrade-Insecure-Requests: 1\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept-Encoding: gzip, deflate\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\"</span>,host);</span><br><span class=\"line\">    request_lenth = <span class=\"built_in\">strlen</span>(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    bzero(&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(port);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;serverAddr.sin_addr.s_addr, server-&gt;h_addr, server-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">usage</span><span class=\"params\">(<span class=\"keyword\">char</span> *name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Usage: %s [thread_count] [concurrent_connections] [total_connection] [hostname]\\n\"</span></span><br><span class=\"line\">                   <span class=\"string\">\"Due to limitation of number of file descriptor,\\n\"</span></span><br><span class=\"line\">                   <span class=\"string\">\"connection per thread should not be too large.\\n\"</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> thread_id;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(argc != <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        usage(argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    thread_count = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    g_max_con = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    g_max_total = atoi(argv[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(thread_count &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(g_max_con &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(g_max_total &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    err = init_print_thread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    epfd = epoll_create1(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    err = init_server(argv[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"No such host\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; thread_count/<span class=\"number\">10</span>; ++index)&#123;</span><br><span class=\"line\">        err = pthread_create(&amp;thread_id, <span class=\"literal\">NULL</span>, connect_thread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; thread_count; ++index)&#123;</span><br><span class=\"line\">        err = pthread_create(&amp;thread_id, <span class=\"literal\">NULL</span>, thread_connetion, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(g_print_thread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x0-学习资料\"><a href=\"#0x0-学习资料\" class=\"headerlink\" title=\"0x0 学习资料\"></a>0x0 学习资料</h1><ul>\n<li>《UNIX网络编程 卷1：套接字API（第三版）》</li>\n<li>《Linux/UNIX系统编程手册》</li>\n<li><a href=\"https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/\" target=\"_blank\" rel=\"noopener\">Epoll is fundamentally broken 1/2</a></li>\n<li><a href=\"https://idea.popcount.org/2017-03-20-epoll-is-fundamentally-broken-22/\" target=\"_blank\" rel=\"noopener\">Epoll is fundamentally broken 2/2</a></li>\n</ul>\n<h1 id=\"0x1-学习路途\"><a href=\"#0x1-学习路途\" class=\"headerlink\" title=\"0x1 学习路途\"></a>0x1 学习路途</h1><p>这次东西深入的比较多，所以先在前面尝试叙述一下学到的一点东西，然后从知识的基础上再来写程序。</p>\n<h2 id=\"非阻塞I-O\"><a href=\"#非阻塞I-O\" class=\"headerlink\" title=\"非阻塞I/O\"></a>非阻塞I/O</h2><p>在上次实现的两个程序中，采用的都是阻塞型I/O模型，所谓阻塞性I/O模型就是指单个线程每次只在一个文件描述符上进行I/O操作（在本例中是一个socket），每次I/O系统调用都会一直阻塞直到完成数据传输，那么只需要出现以下这些情况，那么情况就会变得很麻烦：</p>\n<ul>\n<li>检查文件描述符上是否需要进行I/O</li>\n<li>对没有数据到来的socket调用了read()方法</li>\n<li>需要检查多个文件描述符，查看他们是否可执行I/O</li>\n</ul>\n<p>一旦阻塞上，只能等待操作完成才能进行下一步的操作，这对于许多追求效率的场合都是不能忍受的。于是目前的操作系统都引入了非阻塞I/O的方法。pipe、FIFO、socket、设备都支持非阻塞模式，除了open()外，对于socket、pipe这种无法通过open()获取文件描述符的文件来说，可以使用fcntl()的F_SETFL命令启用非阻塞标志。</p>\n<p>除此之外，对于我们所要使用的socket来说，可以在socket()函数的第二个参数中或上SOCK_NONBLOCK来使得socket变成非阻塞模式，需要注意的是，非阻塞模式的socket在进行connect()的时候会返回负值，并将errno置为EINPROGRESS。</p>\n<h2 id=\"I-O多路复用\"><a href=\"#I-O多路复用\" class=\"headerlink\" title=\"I/O多路复用\"></a>I/O多路复用</h2><p>有了非阻塞I/O模型，那么我们就可以这样提升我们的效率：</p>\n<p>首先对目前有的文件描述符做一个检查，查看是否有可以执行I/O的文件描述符，然后对这些文件描述符执行I/O操作（例如这时可以为这个I/O新开一个线程/进程），这样我们的效率就提升上来了。</p>\n<p>但是显然不应该对已有的文件描述符形成的集合进行不停的遍历，这样效率会被浪费许多，好在Linux提供了一些I/O多路复用的接口，包括select/poll/epoll(Linux 2.6+)</p>\n<p>做一个粗略的比较的话，如果限定在Linux平台上，那么epoll无疑是最好的选择，原因有以下几个：</p>\n<ul>\n<li>文件描述符范围有限制。select底层用数组实现，最大连接数写死</li>\n<li>时间复杂度为O(n)。select/poll在获得事件数后，都需要进行遍历来确认。</li>\n<li>文件描述符拷贝。每次调用select/poll的时候，都会有一次拷贝。</li>\n</ul>\n<p>select/poll/epoll作为三个比较成熟的I/O复用模型，还有很多值得说的东西，但介于一个自己能力不够，另一个时间太少，没法在这里展开叙述了。</p>\n<h2 id=\"多线程I-O复用\"><a href=\"#多线程I-O复用\" class=\"headerlink\" title=\"多线程I/O复用\"></a>多线程I/O复用</h2><p>多线程使用epoll的时候，就需要考虑以下问题：</p>\n<ul>\n<li>各线程的epoll是否是同一个？<ul>\n<li>如果是的话，如何保证调用epoll_wait()获得的event是独立的</li>\n<li>如果不是的话，建立连接的线程该向哪个epoll file descriptor添加</li>\n</ul>\n</li>\n<li>各线程的epoll_event是否是同一个？<ul>\n<li>如果是的话，如何保证他们处理的event是互斥的</li>\n<li>如果不是的话，如何保证他们分别的epoll_event交际是空的</li>\n</ul>\n</li>\n<li>如何保证各线程处理的socket没有交集？</li>\n</ul>\n<p>以及有关性能的其他考虑：</p>\n<ul>\n<li>考虑这样的情况，如果多个处理连接的线程都闲置了，此时突然来了一个I/O请求，会不会发生多线程的争抢？或者单纯多个线程的唤醒是否就是对性能的一个极大的开销？（答案是是的，这个情况被称为thundering herd）</li>\n</ul>\n<h2 id=\"解决途径\"><a href=\"#解决途径\" class=\"headerlink\" title=\"解决途径\"></a>解决途径</h2><p>在讨论问题前需要说明的是，在epoll的文档中，作者用比较暧昧的口气说epoll的几个内置函数都是线程安全的（个人感觉），但是暂时也没时间把它代码读了，所以只好以此为基础来做后面的实现了。</p>\n<p>在读了两篇博文，上网查阅了Linux的资料后，终于解决了基础的问题，答案就是在在Linux2.6.2中新增的EPOLLONESHOT和Linux4.5中新增的EPOLLEXCLUSIVE。</p>\n<p>前者想解决的是这样的问题：</p>\n<p>一个文件描述符可能被多个epoll_wait()拉出来，那么就会出现一个竞争的问题。将事件的属性或上EPOLLONESHOT就可以让它被一个epoll_wait()拉出来以后在内部被禁用。</p>\n<p>后者想解决的则是thundering herd问题：</p>\n<p>如果实例被制定了EPOLLEXCLUSIVE，它们发生事件的时候会只向一个epoll file decriptor发出通知，于是就可以让那个对应的线程接受到事件。</p>\n<p>了解了上面两个标示后，将给出目前的做法和之后优化的思路。</p>\n<h2 id=\"目前思路\"><a href=\"#目前思路\" class=\"headerlink\" title=\"目前思路\"></a>目前思路</h2><img src=\"/2018/03/19/完成一个C语言http服务器压力测试工具（三）/flowchart.png\" title=\"flowchart\">\n<p>我使用了单个epoll file descritptor，每个线程维护自己的epoll_evets数组的方法。每个socket加入epoll的时候，都设置EPOLLONESHOT和EPOLLEXCLUSIVE解决竞争问题。</p>\n<p>我采用了单独开了100线程（后来测试发现，处理读写的线程效率比我想象的还要低，改成了10）用于不断创建socket并完成连接、写数据、将其加入的过程，因为这个实现方式完成读写的效率实在过于低下，只需开这么几个线程建立的连接就可以处理完了，因为这样，这样的实现方式concurrent number只能作为一个上限，测试过程中能有一两秒能达到10000就不错了……</p>\n<p>以及连接总数比较高的时候，会出现</p>\n<img src=\"/2018/03/19/完成一个C语言http服务器压力测试工具（三）/snipaste20180320_005219.png\" title=\"problem\">\n<p>具体原因不明，还在排查中，多线程单连接没出现过这种问题。</p>\n<h2 id=\"优化思路\"><a href=\"#优化思路\" class=\"headerlink\" title=\"优化思路\"></a>优化思路</h2><p>开profile tools正在跑，准备看看哪些调用耗时较大。</p>\n<p>另外从博客中还看到一种新的结构，应该就能实现一个性能不错的压力测试软件了。</p>\n<p>就是开一些线程创建socket连接，用单个线程将epoll_event依次加入一个队列里，处理线程分别向队列里取事件并处理，也就是供应商和客户这个多线程模型。</p>\n<p>这样做的话有这样的问题：</p>\n<ul>\n<li>代码复杂度上升。<ul>\n<li>要实现一个高效的队列，那么可以否决不断malloc/free的做法，而是开辟一块内存固定用来放这个队列，同时应该申请锁或者用信号来避免竞争时间。</li>\n<li>因为是有事件才交给线程处理，所以会有一个线程的不断创建与消亡的代价，这个开销也是很大的，目前了解到的高效的做法是用线程池来提升效率。</li>\n</ul>\n</li>\n<li>没有解决目前的BUG<ul>\n<li>还没了解具体原因，如果是基于错误程序做的优化，依然可能产生同样的错误</li>\n</ul>\n</li>\n<li>socket连接创建加入的操作<ul>\n<li>socket的连接以及加入epoll是由另一些进程处理的，要协同好它们的关系还需要进一步的考虑，这里只能说做了一个比较粗糙的设想，暂时还没有想到/找到更好、更合适的做法。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"0x2-源代码\"><a href=\"#0x2-源代码\" class=\"headerlink\" title=\"0x2 源代码\"></a>0x2 源代码</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/epoll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;asm/errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WAIT_COUNT_MAX 3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOCK_LIST_COUNT 40960</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> EPOLLINEV (EPOLLIN | EPOLLET | EPOLLONESHOT | EPOLLEXCLUSIVE)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> file_descriptor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> response[<span class=\"number\">1024</span>];</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_total = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_max_total = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_con = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_request_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_complete = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_max_con = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> request_lenth;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> thread_count;</span><br><span class=\"line\"><span class=\"keyword\">pthread_t</span> g_print_thread;</span><br><span class=\"line\">file_descriptor epfd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port = <span class=\"number\">80</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">server</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> request[<span class=\"number\">1024</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">print_condition</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">cur_time</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\ttotla_requests\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(g_total &lt; g_max_total) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        gettimeofday(&amp;cur_time, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"%5d\\t%21ld\\t%25d\\t%16d\\t%14d\\n\"</span>,index, cur_time.tv_sec*<span class=\"number\">1000000</span> + cur_time.tv_usec, g_con, g_total, g_request_count);</span><br><span class=\"line\">        __sync_and_and_fetch(&amp;g_con, <span class=\"number\">0</span>);</span><br><span class=\"line\">        ++index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_print_thread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_create(&amp;g_print_thread, <span class=\"literal\">NULL</span>, print_condition, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">make_socket</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    file_descriptor sock;</span><br><span class=\"line\"></span><br><span class=\"line\">    sock = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sock &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Create socket error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sock;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connect_server</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(connect(sock, (struct sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr)) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Connect server error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_nonblock</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> fflag)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> *s = fflag ?<span class=\"string\">\"read\"</span>:<span class=\"string\">\"write\"</span>;</span><br><span class=\"line\">        perror(s);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (flags &amp; O_NONBLOCK) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_nonblock</span><span class=\"params\">(file_descriptor fd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"get fd flags error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    flags |= O_NONBLOCK;</span><br><span class=\"line\">    flags = fcntl(fd, F_SETFL, flags);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"set fd flags error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket_write</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nbytes;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wait_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> send_suc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        nbytes = send(sock, request, request_lenth, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is_nonblock(sock, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (wait_count &lt; WAIT_COUNT_MAX) &#123;</span><br><span class=\"line\">                        ++wait_count;</span><br><span class=\"line\">                        usleep(wait_count);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nbytes == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nbytes == request_lenth)&#123;</span><br><span class=\"line\">            send_suc = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> send_suc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket_read</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nbytes;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wait_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> recv_suc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        nbytes = recv(sock, response, <span class=\"keyword\">sizeof</span>(response) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is_nonblock(sock, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (wait_count &lt; WAIT_COUNT_MAX) &#123;</span><br><span class=\"line\">                        wait_count++;</span><br><span class=\"line\">                        usleep(wait_count);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nbytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            recv_suc = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> recv_suc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_connection</span><span class=\"params\">(file_descriptor epfd)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">ev</span>;</span></span><br><span class=\"line\">    file_descriptor socket;</span><br><span class=\"line\">    socket = make_socket();</span><br><span class=\"line\">    connect_server(socket);</span><br><span class=\"line\">    set_nonblock(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    ev.data.fd = socket;</span><br><span class=\"line\">    socket_write(socket);</span><br><span class=\"line\">    ev.events = EPOLLINEV;</span><br><span class=\"line\">    epoll_ctl(epfd, EPOLL_CTL_ADD, socket, &amp;ev);</span><br><span class=\"line\"></span><br><span class=\"line\">    __sync_fetch_and_add(&amp;g_request_count, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">connect_thread</span><span class=\"params\">(<span class=\"keyword\">void</span> *args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (__sync_fetch_and_add(&amp;g_total, <span class=\"number\">1</span>) &lt; g_max_total)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__sync_fetch_and_add(&amp;g_con, <span class=\"number\">1</span>) &lt; g_max_con)&#123;</span><br><span class=\"line\">            make_connection(epfd);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            __sync_fetch_and_add(&amp;g_con, <span class=\"number\">-1</span>);</span><br><span class=\"line\">            __sync_fetch_and_add(&amp;g_total, <span class=\"number\">-1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">thread_connetion</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    file_descriptor nfds;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">events</span>[<span class=\"title\">SOCK_LIST_COUNT</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        usleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">        nfds = epoll_wait(epfd, events, <span class=\"keyword\">sizeof</span>(events), <span class=\"number\">500</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(index = <span class=\"number\">0</span>; index &lt; nfds; ++index)&#123;</span><br><span class=\"line\">            file_descriptor fd = events[index].data.fd;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(events[index].events &amp; EPOLLIN)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!socket_read(fd))&#123;</span><br><span class=\"line\">                    epoll_ctl(epfd, EPOLL_CTL_DEL, fd, events);</span><br><span class=\"line\">                    close(fd);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_server</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *host)</span></span>&#123;</span><br><span class=\"line\">    server = gethostbyname(host);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(server == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">sprintf</span>(request,<span class=\"string\">\"GET  HTTP/1.1\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Host: %s\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Connection: keep-alive\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Cache-Control: max-age=0\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Upgrade-Insecure-Requests: 1\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept-Encoding: gzip, deflate\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\"</span>,host);</span><br><span class=\"line\">    request_lenth = <span class=\"built_in\">strlen</span>(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    bzero(&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(port);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;serverAddr.sin_addr.s_addr, server-&gt;h_addr, server-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">usage</span><span class=\"params\">(<span class=\"keyword\">char</span> *name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Usage: %s [thread_count] [concurrent_connections] [total_connection] [hostname]\\n\"</span></span><br><span class=\"line\">                   <span class=\"string\">\"Due to limitation of number of file descriptor,\\n\"</span></span><br><span class=\"line\">                   <span class=\"string\">\"connection per thread should not be too large.\\n\"</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> thread_id;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(argc != <span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">        usage(argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    thread_count = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    g_max_con = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    g_max_total = atoi(argv[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(thread_count &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(g_max_con &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(g_max_total &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    err = init_print_thread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    epfd = epoll_create1(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    err = init_server(argv[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"No such host\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; thread_count/<span class=\"number\">10</span>; ++index)&#123;</span><br><span class=\"line\">        err = pthread_create(&amp;thread_id, <span class=\"literal\">NULL</span>, connect_thread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; thread_count; ++index)&#123;</span><br><span class=\"line\">        err = pthread_create(&amp;thread_id, <span class=\"literal\">NULL</span>, thread_connetion, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(g_print_thread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"完成一个C语言http服务器压力测试工具（二）","connments":true,"date":"2018-03-17T16:26:15.000Z","desc":"完成一个C语言http服务器压力测试工具（二）","summary":"复习加深入了解的机会~","_content":"\n# 0x0 学习资料\n\nhttps://stackoverflow.com/\n\nhttp://man7.org/index.html\n\n《Linux/UNIX系统编程手册》\n\n《UNIX网络编程 卷1：套接字API（第三版）》\n\n# 0x1 已加入多线程豪华套餐\n\n还是先把代码放出来慢慢分析\n\n```c\n#include <stdio.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <string.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <asm/errno.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#define READ_TIMEOUT_S 3\n#define READ_TIMEOUT_US 0\n#define WRITE_TIMEOUT_S 3\n#define WRITE_TIMEOUT_US 0\n#define WAIT_COUNT_MAX 3\n\ntypedef int file_descriptor;\n\nchar response[1024];\nstatic int g_total = 0;\nstatic int g_max_total = 100000;\nstatic int g_con = 0;\nstatic int g_request_count = 0;\nstatic int g_complete = 0;\nstatic int request_lenth;\npthread_t g_print_thread;\n\n\nstatic const int port = 80;\nstatic char *host = \"localhost\";\nstruct hostent *server;\nstruct sockaddr_in serverAddr;\nstatic char *request = \"GET http://10.10.10.138/ HTTP/1.1\\r\\n\"\n        \"Host: 10.10.10.138\\r\\n\"\n        \"Connection: keep-alive\\r\\n\"\n        \"Cache-Control: max-age=0\\r\\n\"\n        \"Upgrade-Insecure-Requests: 1\\r\\n\"\n        \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"\n        \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"\n        \"Accept-Encoding: gzip, deflate\\r\\n\"\n        \"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\";\n\nvoid *print_condition(void *arg){\n    struct timeval cur_time;\n    int index = 0;\n    fprintf(stdout, \"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\n\");\n    while(1) {\n        sleep(1);\n        gettimeofday(&cur_time, NULL);\n        fprintf(stdout, \"%5d\\t%21ld\\t%25d\\t%16d\\n\",index, cur_time.tv_sec*1000000 + cur_time.tv_usec, g_con, g_total);\n        __sync_and_and_fetch(&g_con, 0);\n        ++index;\n    }\n}\n\nint init_print_thread(){\n    return pthread_create(&g_print_thread, NULL, print_condition, NULL);\n}\n\n\nint make_socket(){\n    file_descriptor sock;\n\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if(sock < 0){\n        perror(\"Create socket error\");\n        exit(EXIT_FAILURE);\n    }\n\n    return sock;\n}\n\nvoid connect_server(file_descriptor sock){\n    if(connect(sock, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0){\n        perror(\"Connect server error\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid set_block_filedes_timeout(file_descriptor filedes) {\n    struct timeval tv_out, tv_in;\n\n    tv_in.tv_sec = READ_TIMEOUT_S;\n    tv_in.tv_usec = READ_TIMEOUT_US;\n    if (setsockopt(filedes, SOL_SOCKET, SO_RCVTIMEO, &tv_in, sizeof(tv_in)) < 0) {\n        perror(\"set rcv timeout error\");\n        exit(EXIT_FAILURE);\n    }\n\n    tv_out.tv_sec = WRITE_TIMEOUT_S;\n    tv_out.tv_usec = WRITE_TIMEOUT_US;\n    if (setsockopt(filedes, SOL_SOCKET, SO_SNDTIMEO, &tv_out, sizeof(tv_out)) < 0) {\n        perror(\"set rcv timeout error\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint is_nonblock(file_descriptor fd) {\n    int flags = fcntl(fd, F_GETFL);\n    if (flags == -1) {\n        perror(\"get fd flags error\");\n        exit(EXIT_FAILURE);\n    }\n    return (flags & O_NONBLOCK) ? 1 : 0;\n}\n\nint socket_write(file_descriptor sock){\n    int nbytes;\n    int wait_count = 0;\n    int send_suc = 1;\n    while (1) {\n        nbytes = send(sock, request, request_lenth, 0);\n\n        if (nbytes < 0) {\n            if (is_nonblock(sock)) {\n                if (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno){\n                    if (wait_count < WAIT_COUNT_MAX) {\n                        ++wait_count;\n                        usleep(wait_count);\n                        continue;\n                    }\n                }\n            }\n            break;\n        } else if (nbytes == 0) {\n            break;\n        } else if(nbytes == request_lenth){\n            send_suc = 0;\n            break;\n        }\n    }\n\n    return send_suc;\n}\n\nint socket_read(file_descriptor sock){\n    int nbytes;\n    int wait_count = 0;\n    int recv_suc = 1;\n    while (1) {\n        nbytes = recv(sock, response, sizeof(response) - 1, 0);\n        if (nbytes < 0) {\n            if (is_nonblock(sock)) {\n                if (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno){\n                    if (wait_count < WAIT_COUNT_MAX) {\n                        wait_count++;\n                        usleep(wait_count);\n                        continue;\n                    }\n                }\n            }\n            break;\n        }\n        if (nbytes == 0) {\n            break;\n        } else if (nbytes > 0) {\n            recv_suc = 0;\n        }\n    }\n    return recv_suc;\n}\n\nvoid *thread_connetion(void *arg){\n    file_descriptor socket;\n\n    while(__sync_fetch_and_add(&g_total, 1) < g_max_total){\n        __sync_fetch_and_add(&g_con, 1);\n        socket = make_socket();\n        connect_server(socket);\n        set_block_filedes_timeout(socket);\n        __sync_fetch_and_add(&g_request_count, 1);\n        if(!socket_write(socket)){\n            if(!socket_read(socket)){\n                __sync_fetch_and_add(&g_complete, 1);\n            }\n        }\n        close(socket);\n    }\n}\n\nint init_server(){\n    server = gethostbyname(host);\n    if(server == NULL){\n        return -1;\n    }\n\n    bzero(&serverAddr, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    memcpy(&serverAddr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n    return 0;\n}\n\nvoid usage(char *name){\n    printf(\"Usage: %s [thread_count] [total_connection]\\nDue to limitation of number of file descriptor, thread count should not greater than 1024.\\n\", name);\n}\n\nint main(int argc, char **argv) {\n    int thread_count;\n    int err;\n    pthread_t thread_id;\n    int index;\n    request_lenth = strlen(request);\n\n    if(argc != 3){\n        usage(argv[0]);\n        exit(EXIT_SUCCESS);\n    }\n    thread_count = atoi(argv[1]);\n    g_max_total = atoi(argv[2]);\n\n    err = init_print_thread();\n    if(err < 0){\n        perror(\"Create print thread error\");\n        exit(EXIT_FAILURE);\n    }\n\n    err = init_server();\n    if(err < 0){\n        perror(\"No such host\");\n    }\n\n    for (index = 0; index < thread_count; ++index){\n        err = pthread_create(&thread_id, NULL, thread_connetion, NULL);\n        if(err < 0){\n            perror(\"Create print thread error\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    pthread_join(g_print_thread, NULL);\n    exit(EXIT_SUCCESS);\n}\n```\n\n接下来会按照函数调用关系从整体到细节来分析这个程序\n\n## 主函数\n\n首先是加入了可控的参数，一个是线程数，另一个是总连接数，使用方法不对的时候调用usage()输出用法并退出程序。\n\n```c\nvoid usage(char *name){\n    printf(\"Usage: %s [thread_count] [total_connection]\\nDue to limitation of number of file descriptor, thread count should not greater than 1024.\\n\", name);\n}\n```\n\n为了能直观观察连接情况，所以在执行之前，启动一个打印统计信息的现场，同时这个线程之后还要继续用\n\n``` c\n    err = init_print_thread();\n    if(err < 0){\n        perror(\"Create print thread error\");\n        exit(EXIT_FAILURE);\n    }\n```\n\n如果统计都搞不了，那这个测试也没用了，所以失败直接退出。\n\n函数定义如下：\n\n```c\nint init_print_thread(){\n    return pthread_create(&g_print_thread, NULL, print_condition, NULL);\n}\n\nvoid *print_condition(void *arg){\n    struct timeval cur_time;\n    int index = 0;\n    fprintf(stdout, \"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\n\");\n    while(g_total < g_max_total) {\n        sleep(1);\n        gettimeofday(&cur_time, NULL);\n        fprintf(stdout, \"%5d\\t%21ld\\t%25d\\t%16d\\n\",index, cur_time.tv_sec*1000000 + cur_time.tv_usec, g_con, g_total);\n        __sync_and_and_fetch(&g_con, 0);\n        ++index;\n    }\n}\n```\n\n打印的参数中，g_con是这一秒完成的连接数量（发生请求并接受响应成功计一次连接），g_total为目前的总连接数。\n\n考虑到我们只是想进行压力测试，所以对并不想保留数据，而且发起连接的信息都是一样的，所以也可以看到，之前的int port、char \\*host = \"localhost\"、struct hostent \\*server、struct sockaddr_in serverAddr都变成了全局变量，在创建连接前对其进行初始化。\n\n```c\n    err = init_server();\n    if(err < 0){\n        perror(\"No such host\");\n    }\n```\n\ninit_server()的内容就是之前的直接搬了过来\n\n```c\nint init_server(){\n    server = gethostbyname(host);\n    if(server == NULL){\n        return -1;\n    }\n\n    bzero(&serverAddr, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    memcpy(&serverAddr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n    return 0;\n}\n```\n\n然后就创建传入参数个线程\n\n```c\n   for (index = 0; index < thread_count; ++index){\n        err = pthread_create(&thread_id, NULL, thread_connetion, NULL);\n        if(err < 0){\n            perror(\"Create print thread error\");\n            exit(EXIT_FAILURE);\n        }\n    }\n```\n\n最后用在打印的线程中判断是否结束，达到连接总数后结束\n\n``` c\n    pthread_join(g_print_thread, NULL);\n```\n\n## 线程，启动！\n\n```c\nvoid *thread_connetion(void *arg){\n    file_descriptor socket;\n\n    while(__sync_fetch_and_add(&g_total, 1) < g_max_total){\n        __sync_fetch_and_add(&g_con, 1);\n        socket = make_socket();\n        connect_server(socket);\n        set_block_filedes_timeout(socket);\n        __sync_fetch_and_add(&g_request_count, 1);\n        if(!socket_write(socket)){\n            if(!socket_read(socket)){\n                __sync_fetch_and_add(&g_complete, 1);\n            }\n        }\n        close(socket);\n    }\n}\n```\n\n对于个线程来说，要做的就是两件事，一个是http连接，另一个是计数。\n\n好消息是http连接用的函数都是线程安全的（根据书上写的，没有看SUSv3），所以前者就是把之前的事情放进函数体就好了。\n\n还有一些改动，比如判断是否阻塞，设置超时时限，这个是为了之后在实现I/O复用的时候复用这些函数。\n\n而后面一个操作需要考虑计数所用的变量肯定是各个线程都有的，所以必须要进行处理。\n\n学了汇编的朋友就知道，即使是一句简单的\n\n```c\ni++;\n```\n\n也往往不是一个指令完成的，可能是这样的三个指令：\n\n```assembly\nmov eax, [esi + 1]\nadd eax, 1\nmov [esi + 1], eax\n```\n\n假如一个线程在执行完第一句汇编以后，第二个线程开始执行第一个语句，那么结果就不对了。\n\n目前我知道的有锁、信号两种方法，但是好在Linux提供了一系列原子操作，直接用就好了。所谓原子操作中的原子，意思就和这个词的来历一样，就是指不可分割的一个操作，它要么全部不完成，要么完全生效，没有中间状态。\n\n## 改文件描述符上限\n\n目前这个程序线程与连接是一个1:1的关系，在测试时我发现只要线程数目超过1000多一点，就会无法创建连接。搜索后发现是文件描述符上限的问题。\n\n在bash用命令ulimit -a就能看到文件描述符的上限（在我的Ubuntu14上是1024），如果达到这个上限就会出现无法创建新连接的情况，所以需要改一下。我按照 http://blog.csdn.net/kimsoft/article/details/8024216 把上限改高以后就可以超过1000了。\n\n# 0x2 总结与挖掘\n\n第二篇笔记里，实现了大致以1s为周期的信息统计、多线程请求。这次学习中，我觉得还能深挖的东西有：\n\n- 我在提升文件描述符上限后又遇到另一个问题，就是数量达到大概13000的时候出现了Broken pipe的错误，在提升虚拟机配置后问题有所缓解，但是形成原理目前没有头绪。\n- 在提升配置后，虽然没有出现错误，但是线程和连接数无法达到1:1的关系了，比如输入./a.out 50000 1000000后，每秒连接数量大致稳定在2w3左右，但是即使是拿主机而非虚拟机访问服务器也是很流畅的，也就是说瓶颈应该还是在我的程序中，但是瓶颈究竟在哪里？","source":"_posts/完成一个C语言http服务器压力测试工具（二）.md","raw":"---\ntitle: 完成一个C语言http服务器压力测试工具（二）\nconnments: true\ndate: 2018-03-18 00:26:15\ntags: \n\t- C\n\t- Software Development\ncategories: Notes\ndesc: 完成一个C语言http服务器压力测试工具（二）\nsummary: 复习加深入了解的机会~\n---\n\n# 0x0 学习资料\n\nhttps://stackoverflow.com/\n\nhttp://man7.org/index.html\n\n《Linux/UNIX系统编程手册》\n\n《UNIX网络编程 卷1：套接字API（第三版）》\n\n# 0x1 已加入多线程豪华套餐\n\n还是先把代码放出来慢慢分析\n\n```c\n#include <stdio.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <string.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <asm/errno.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#define READ_TIMEOUT_S 3\n#define READ_TIMEOUT_US 0\n#define WRITE_TIMEOUT_S 3\n#define WRITE_TIMEOUT_US 0\n#define WAIT_COUNT_MAX 3\n\ntypedef int file_descriptor;\n\nchar response[1024];\nstatic int g_total = 0;\nstatic int g_max_total = 100000;\nstatic int g_con = 0;\nstatic int g_request_count = 0;\nstatic int g_complete = 0;\nstatic int request_lenth;\npthread_t g_print_thread;\n\n\nstatic const int port = 80;\nstatic char *host = \"localhost\";\nstruct hostent *server;\nstruct sockaddr_in serverAddr;\nstatic char *request = \"GET http://10.10.10.138/ HTTP/1.1\\r\\n\"\n        \"Host: 10.10.10.138\\r\\n\"\n        \"Connection: keep-alive\\r\\n\"\n        \"Cache-Control: max-age=0\\r\\n\"\n        \"Upgrade-Insecure-Requests: 1\\r\\n\"\n        \"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"\n        \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"\n        \"Accept-Encoding: gzip, deflate\\r\\n\"\n        \"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\";\n\nvoid *print_condition(void *arg){\n    struct timeval cur_time;\n    int index = 0;\n    fprintf(stdout, \"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\n\");\n    while(1) {\n        sleep(1);\n        gettimeofday(&cur_time, NULL);\n        fprintf(stdout, \"%5d\\t%21ld\\t%25d\\t%16d\\n\",index, cur_time.tv_sec*1000000 + cur_time.tv_usec, g_con, g_total);\n        __sync_and_and_fetch(&g_con, 0);\n        ++index;\n    }\n}\n\nint init_print_thread(){\n    return pthread_create(&g_print_thread, NULL, print_condition, NULL);\n}\n\n\nint make_socket(){\n    file_descriptor sock;\n\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if(sock < 0){\n        perror(\"Create socket error\");\n        exit(EXIT_FAILURE);\n    }\n\n    return sock;\n}\n\nvoid connect_server(file_descriptor sock){\n    if(connect(sock, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0){\n        perror(\"Connect server error\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid set_block_filedes_timeout(file_descriptor filedes) {\n    struct timeval tv_out, tv_in;\n\n    tv_in.tv_sec = READ_TIMEOUT_S;\n    tv_in.tv_usec = READ_TIMEOUT_US;\n    if (setsockopt(filedes, SOL_SOCKET, SO_RCVTIMEO, &tv_in, sizeof(tv_in)) < 0) {\n        perror(\"set rcv timeout error\");\n        exit(EXIT_FAILURE);\n    }\n\n    tv_out.tv_sec = WRITE_TIMEOUT_S;\n    tv_out.tv_usec = WRITE_TIMEOUT_US;\n    if (setsockopt(filedes, SOL_SOCKET, SO_SNDTIMEO, &tv_out, sizeof(tv_out)) < 0) {\n        perror(\"set rcv timeout error\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint is_nonblock(file_descriptor fd) {\n    int flags = fcntl(fd, F_GETFL);\n    if (flags == -1) {\n        perror(\"get fd flags error\");\n        exit(EXIT_FAILURE);\n    }\n    return (flags & O_NONBLOCK) ? 1 : 0;\n}\n\nint socket_write(file_descriptor sock){\n    int nbytes;\n    int wait_count = 0;\n    int send_suc = 1;\n    while (1) {\n        nbytes = send(sock, request, request_lenth, 0);\n\n        if (nbytes < 0) {\n            if (is_nonblock(sock)) {\n                if (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno){\n                    if (wait_count < WAIT_COUNT_MAX) {\n                        ++wait_count;\n                        usleep(wait_count);\n                        continue;\n                    }\n                }\n            }\n            break;\n        } else if (nbytes == 0) {\n            break;\n        } else if(nbytes == request_lenth){\n            send_suc = 0;\n            break;\n        }\n    }\n\n    return send_suc;\n}\n\nint socket_read(file_descriptor sock){\n    int nbytes;\n    int wait_count = 0;\n    int recv_suc = 1;\n    while (1) {\n        nbytes = recv(sock, response, sizeof(response) - 1, 0);\n        if (nbytes < 0) {\n            if (is_nonblock(sock)) {\n                if (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno){\n                    if (wait_count < WAIT_COUNT_MAX) {\n                        wait_count++;\n                        usleep(wait_count);\n                        continue;\n                    }\n                }\n            }\n            break;\n        }\n        if (nbytes == 0) {\n            break;\n        } else if (nbytes > 0) {\n            recv_suc = 0;\n        }\n    }\n    return recv_suc;\n}\n\nvoid *thread_connetion(void *arg){\n    file_descriptor socket;\n\n    while(__sync_fetch_and_add(&g_total, 1) < g_max_total){\n        __sync_fetch_and_add(&g_con, 1);\n        socket = make_socket();\n        connect_server(socket);\n        set_block_filedes_timeout(socket);\n        __sync_fetch_and_add(&g_request_count, 1);\n        if(!socket_write(socket)){\n            if(!socket_read(socket)){\n                __sync_fetch_and_add(&g_complete, 1);\n            }\n        }\n        close(socket);\n    }\n}\n\nint init_server(){\n    server = gethostbyname(host);\n    if(server == NULL){\n        return -1;\n    }\n\n    bzero(&serverAddr, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    memcpy(&serverAddr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n    return 0;\n}\n\nvoid usage(char *name){\n    printf(\"Usage: %s [thread_count] [total_connection]\\nDue to limitation of number of file descriptor, thread count should not greater than 1024.\\n\", name);\n}\n\nint main(int argc, char **argv) {\n    int thread_count;\n    int err;\n    pthread_t thread_id;\n    int index;\n    request_lenth = strlen(request);\n\n    if(argc != 3){\n        usage(argv[0]);\n        exit(EXIT_SUCCESS);\n    }\n    thread_count = atoi(argv[1]);\n    g_max_total = atoi(argv[2]);\n\n    err = init_print_thread();\n    if(err < 0){\n        perror(\"Create print thread error\");\n        exit(EXIT_FAILURE);\n    }\n\n    err = init_server();\n    if(err < 0){\n        perror(\"No such host\");\n    }\n\n    for (index = 0; index < thread_count; ++index){\n        err = pthread_create(&thread_id, NULL, thread_connetion, NULL);\n        if(err < 0){\n            perror(\"Create print thread error\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    pthread_join(g_print_thread, NULL);\n    exit(EXIT_SUCCESS);\n}\n```\n\n接下来会按照函数调用关系从整体到细节来分析这个程序\n\n## 主函数\n\n首先是加入了可控的参数，一个是线程数，另一个是总连接数，使用方法不对的时候调用usage()输出用法并退出程序。\n\n```c\nvoid usage(char *name){\n    printf(\"Usage: %s [thread_count] [total_connection]\\nDue to limitation of number of file descriptor, thread count should not greater than 1024.\\n\", name);\n}\n```\n\n为了能直观观察连接情况，所以在执行之前，启动一个打印统计信息的现场，同时这个线程之后还要继续用\n\n``` c\n    err = init_print_thread();\n    if(err < 0){\n        perror(\"Create print thread error\");\n        exit(EXIT_FAILURE);\n    }\n```\n\n如果统计都搞不了，那这个测试也没用了，所以失败直接退出。\n\n函数定义如下：\n\n```c\nint init_print_thread(){\n    return pthread_create(&g_print_thread, NULL, print_condition, NULL);\n}\n\nvoid *print_condition(void *arg){\n    struct timeval cur_time;\n    int index = 0;\n    fprintf(stdout, \"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\n\");\n    while(g_total < g_max_total) {\n        sleep(1);\n        gettimeofday(&cur_time, NULL);\n        fprintf(stdout, \"%5d\\t%21ld\\t%25d\\t%16d\\n\",index, cur_time.tv_sec*1000000 + cur_time.tv_usec, g_con, g_total);\n        __sync_and_and_fetch(&g_con, 0);\n        ++index;\n    }\n}\n```\n\n打印的参数中，g_con是这一秒完成的连接数量（发生请求并接受响应成功计一次连接），g_total为目前的总连接数。\n\n考虑到我们只是想进行压力测试，所以对并不想保留数据，而且发起连接的信息都是一样的，所以也可以看到，之前的int port、char \\*host = \"localhost\"、struct hostent \\*server、struct sockaddr_in serverAddr都变成了全局变量，在创建连接前对其进行初始化。\n\n```c\n    err = init_server();\n    if(err < 0){\n        perror(\"No such host\");\n    }\n```\n\ninit_server()的内容就是之前的直接搬了过来\n\n```c\nint init_server(){\n    server = gethostbyname(host);\n    if(server == NULL){\n        return -1;\n    }\n\n    bzero(&serverAddr, sizeof(serverAddr));\n    serverAddr.sin_family = AF_INET;\n    serverAddr.sin_port = htons(port);\n    memcpy(&serverAddr.sin_addr.s_addr, server->h_addr, server->h_length);\n\n    return 0;\n}\n```\n\n然后就创建传入参数个线程\n\n```c\n   for (index = 0; index < thread_count; ++index){\n        err = pthread_create(&thread_id, NULL, thread_connetion, NULL);\n        if(err < 0){\n            perror(\"Create print thread error\");\n            exit(EXIT_FAILURE);\n        }\n    }\n```\n\n最后用在打印的线程中判断是否结束，达到连接总数后结束\n\n``` c\n    pthread_join(g_print_thread, NULL);\n```\n\n## 线程，启动！\n\n```c\nvoid *thread_connetion(void *arg){\n    file_descriptor socket;\n\n    while(__sync_fetch_and_add(&g_total, 1) < g_max_total){\n        __sync_fetch_and_add(&g_con, 1);\n        socket = make_socket();\n        connect_server(socket);\n        set_block_filedes_timeout(socket);\n        __sync_fetch_and_add(&g_request_count, 1);\n        if(!socket_write(socket)){\n            if(!socket_read(socket)){\n                __sync_fetch_and_add(&g_complete, 1);\n            }\n        }\n        close(socket);\n    }\n}\n```\n\n对于个线程来说，要做的就是两件事，一个是http连接，另一个是计数。\n\n好消息是http连接用的函数都是线程安全的（根据书上写的，没有看SUSv3），所以前者就是把之前的事情放进函数体就好了。\n\n还有一些改动，比如判断是否阻塞，设置超时时限，这个是为了之后在实现I/O复用的时候复用这些函数。\n\n而后面一个操作需要考虑计数所用的变量肯定是各个线程都有的，所以必须要进行处理。\n\n学了汇编的朋友就知道，即使是一句简单的\n\n```c\ni++;\n```\n\n也往往不是一个指令完成的，可能是这样的三个指令：\n\n```assembly\nmov eax, [esi + 1]\nadd eax, 1\nmov [esi + 1], eax\n```\n\n假如一个线程在执行完第一句汇编以后，第二个线程开始执行第一个语句，那么结果就不对了。\n\n目前我知道的有锁、信号两种方法，但是好在Linux提供了一系列原子操作，直接用就好了。所谓原子操作中的原子，意思就和这个词的来历一样，就是指不可分割的一个操作，它要么全部不完成，要么完全生效，没有中间状态。\n\n## 改文件描述符上限\n\n目前这个程序线程与连接是一个1:1的关系，在测试时我发现只要线程数目超过1000多一点，就会无法创建连接。搜索后发现是文件描述符上限的问题。\n\n在bash用命令ulimit -a就能看到文件描述符的上限（在我的Ubuntu14上是1024），如果达到这个上限就会出现无法创建新连接的情况，所以需要改一下。我按照 http://blog.csdn.net/kimsoft/article/details/8024216 把上限改高以后就可以超过1000了。\n\n# 0x2 总结与挖掘\n\n第二篇笔记里，实现了大致以1s为周期的信息统计、多线程请求。这次学习中，我觉得还能深挖的东西有：\n\n- 我在提升文件描述符上限后又遇到另一个问题，就是数量达到大概13000的时候出现了Broken pipe的错误，在提升虚拟机配置后问题有所缓解，但是形成原理目前没有头绪。\n- 在提升配置后，虽然没有出现错误，但是线程和连接数无法达到1:1的关系了，比如输入./a.out 50000 1000000后，每秒连接数量大致稳定在2w3左右，但是即使是拿主机而非虚拟机访问服务器也是很流畅的，也就是说瓶颈应该还是在我的程序中，但是瓶颈究竟在哪里？","slug":"完成一个C语言http服务器压力测试工具（二）","published":1,"updated":"2018-03-17T17:25:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgqnsczt000cdkudfh95ed01","content":"<h1 id=\"0x0-学习资料\"><a href=\"#0x0-学习资料\" class=\"headerlink\" title=\"0x0 学习资料\"></a>0x0 学习资料</h1><p><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/</a></p>\n<p><a href=\"http://man7.org/index.html\" target=\"_blank\" rel=\"noopener\">http://man7.org/index.html</a></p>\n<p>《Linux/UNIX系统编程手册》</p>\n<p>《UNIX网络编程 卷1：套接字API（第三版）》</p>\n<h1 id=\"0x1-已加入多线程豪华套餐\"><a href=\"#0x1-已加入多线程豪华套餐\" class=\"headerlink\" title=\"0x1 已加入多线程豪华套餐\"></a>0x1 已加入多线程豪华套餐</h1><p>还是先把代码放出来慢慢分析</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;asm/errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> READ_TIMEOUT_S 3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> READ_TIMEOUT_US 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WRITE_TIMEOUT_S 3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WRITE_TIMEOUT_US 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WAIT_COUNT_MAX 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> file_descriptor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> response[<span class=\"number\">1024</span>];</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_total = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_max_total = <span class=\"number\">100000</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_con = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_request_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_complete = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> request_lenth;</span><br><span class=\"line\"><span class=\"keyword\">pthread_t</span> g_print_thread;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port = <span class=\"number\">80</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> *host = <span class=\"string\">\"localhost\"</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">server</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> *request = <span class=\"string\">\"GET http://10.10.10.138/ HTTP/1.1\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Host: 10.10.10.138\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Connection: keep-alive\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Cache-Control: max-age=0\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Upgrade-Insecure-Requests: 1\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept-Encoding: gzip, deflate\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">print_condition</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">cur_time</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        gettimeofday(&amp;cur_time, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"%5d\\t%21ld\\t%25d\\t%16d\\n\"</span>,index, cur_time.tv_sec*<span class=\"number\">1000000</span> + cur_time.tv_usec, g_con, g_total);</span><br><span class=\"line\">        __sync_and_and_fetch(&amp;g_con, <span class=\"number\">0</span>);</span><br><span class=\"line\">        ++index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_print_thread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_create(&amp;g_print_thread, <span class=\"literal\">NULL</span>, print_condition, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">make_socket</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    file_descriptor sock;</span><br><span class=\"line\"></span><br><span class=\"line\">    sock = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sock &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Create socket error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sock;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connect_server</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(connect(sock, (struct sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr)) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Connect server error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_block_filedes_timeout</span><span class=\"params\">(file_descriptor filedes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_out</span>, <span class=\"title\">tv_in</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tv_in.tv_sec = READ_TIMEOUT_S;</span><br><span class=\"line\">    tv_in.tv_usec = READ_TIMEOUT_US;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setsockopt(filedes, SOL_SOCKET, SO_RCVTIMEO, &amp;tv_in, <span class=\"keyword\">sizeof</span>(tv_in)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"set rcv timeout error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tv_out.tv_sec = WRITE_TIMEOUT_S;</span><br><span class=\"line\">    tv_out.tv_usec = WRITE_TIMEOUT_US;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setsockopt(filedes, SOL_SOCKET, SO_SNDTIMEO, &amp;tv_out, <span class=\"keyword\">sizeof</span>(tv_out)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"set rcv timeout error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_nonblock</span><span class=\"params\">(file_descriptor fd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"get fd flags error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (flags &amp; O_NONBLOCK) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket_write</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nbytes;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wait_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> send_suc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        nbytes = send(sock, request, request_lenth, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is_nonblock(sock)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (wait_count &lt; WAIT_COUNT_MAX) &#123;</span><br><span class=\"line\">                        ++wait_count;</span><br><span class=\"line\">                        usleep(wait_count);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nbytes == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nbytes == request_lenth)&#123;</span><br><span class=\"line\">            send_suc = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> send_suc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket_read</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nbytes;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wait_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> recv_suc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        nbytes = recv(sock, response, <span class=\"keyword\">sizeof</span>(response) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is_nonblock(sock)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (wait_count &lt; WAIT_COUNT_MAX) &#123;</span><br><span class=\"line\">                        wait_count++;</span><br><span class=\"line\">                        usleep(wait_count);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nbytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            recv_suc = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> recv_suc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">thread_connetion</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    file_descriptor socket;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(__sync_fetch_and_add(&amp;g_total, <span class=\"number\">1</span>) &lt; g_max_total)&#123;</span><br><span class=\"line\">        __sync_fetch_and_add(&amp;g_con, <span class=\"number\">1</span>);</span><br><span class=\"line\">        socket = make_socket();</span><br><span class=\"line\">        connect_server(socket);</span><br><span class=\"line\">        set_block_filedes_timeout(socket);</span><br><span class=\"line\">        __sync_fetch_and_add(&amp;g_request_count, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!socket_write(socket))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!socket_read(socket))&#123;</span><br><span class=\"line\">                __sync_fetch_and_add(&amp;g_complete, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        close(socket);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_server</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    server = gethostbyname(host);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(server == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bzero(&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(port);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;serverAddr.sin_addr.s_addr, server-&gt;h_addr, server-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">usage</span><span class=\"params\">(<span class=\"keyword\">char</span> *name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Usage: %s [thread_count] [total_connection]\\nDue to limitation of number of file descriptor, thread count should not greater than 1024.\\n\"</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> thread_count;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> thread_id;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    request_lenth = <span class=\"built_in\">strlen</span>(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(argc != <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">        usage(argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    thread_count = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    g_max_total = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    err = init_print_thread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = init_server();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"No such host\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; thread_count; ++index)&#123;</span><br><span class=\"line\">        err = pthread_create(&amp;thread_id, <span class=\"literal\">NULL</span>, thread_connetion, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(g_print_thread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来会按照函数调用关系从整体到细节来分析这个程序</p>\n<h2 id=\"主函数\"><a href=\"#主函数\" class=\"headerlink\" title=\"主函数\"></a>主函数</h2><p>首先是加入了可控的参数，一个是线程数，另一个是总连接数，使用方法不对的时候调用usage()输出用法并退出程序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">usage</span><span class=\"params\">(<span class=\"keyword\">char</span> *name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Usage: %s [thread_count] [total_connection]\\nDue to limitation of number of file descriptor, thread count should not greater than 1024.\\n\"</span>, name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能直观观察连接情况，所以在执行之前，启动一个打印统计信息的现场，同时这个线程之后还要继续用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err = init_print_thread();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果统计都搞不了，那这个测试也没用了，所以失败直接退出。</p>\n<p>函数定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_print_thread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_create(&amp;g_print_thread, <span class=\"literal\">NULL</span>, print_condition, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">print_condition</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">cur_time</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(g_total &lt; g_max_total) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        gettimeofday(&amp;cur_time, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"%5d\\t%21ld\\t%25d\\t%16d\\n\"</span>,index, cur_time.tv_sec*<span class=\"number\">1000000</span> + cur_time.tv_usec, g_con, g_total);</span><br><span class=\"line\">        __sync_and_and_fetch(&amp;g_con, <span class=\"number\">0</span>);</span><br><span class=\"line\">        ++index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印的参数中，g_con是这一秒完成的连接数量（发生请求并接受响应成功计一次连接），g_total为目前的总连接数。</p>\n<p>考虑到我们只是想进行压力测试，所以对并不想保留数据，而且发起连接的信息都是一样的，所以也可以看到，之前的int port、char *host = “localhost”、struct hostent *server、struct sockaddr_in serverAddr都变成了全局变量，在创建连接前对其进行初始化。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err = init_server();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"No such host\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>init_server()的内容就是之前的直接搬了过来</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_server</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    server = gethostbyname(host);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(server == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bzero(&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(port);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;serverAddr.sin_addr.s_addr, server-&gt;h_addr, server-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后就创建传入参数个线程</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; thread_count; ++index)&#123;</span><br><span class=\"line\">     err = pthread_create(&amp;thread_id, <span class=\"literal\">NULL</span>, thread_connetion, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">         perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>最后用在打印的线程中判断是否结束，达到连接总数后结束</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_join(g_print_thread, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程，启动！\"><a href=\"#线程，启动！\" class=\"headerlink\" title=\"线程，启动！\"></a>线程，启动！</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">thread_connetion</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    file_descriptor socket;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(__sync_fetch_and_add(&amp;g_total, <span class=\"number\">1</span>) &lt; g_max_total)&#123;</span><br><span class=\"line\">        __sync_fetch_and_add(&amp;g_con, <span class=\"number\">1</span>);</span><br><span class=\"line\">        socket = make_socket();</span><br><span class=\"line\">        connect_server(socket);</span><br><span class=\"line\">        set_block_filedes_timeout(socket);</span><br><span class=\"line\">        __sync_fetch_and_add(&amp;g_request_count, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!socket_write(socket))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!socket_read(socket))&#123;</span><br><span class=\"line\">                __sync_fetch_and_add(&amp;g_complete, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        close(socket);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于个线程来说，要做的就是两件事，一个是http连接，另一个是计数。</p>\n<p>好消息是http连接用的函数都是线程安全的（根据书上写的，没有看SUSv3），所以前者就是把之前的事情放进函数体就好了。</p>\n<p>还有一些改动，比如判断是否阻塞，设置超时时限，这个是为了之后在实现I/O复用的时候复用这些函数。</p>\n<p>而后面一个操作需要考虑计数所用的变量肯定是各个线程都有的，所以必须要进行处理。</p>\n<p>学了汇编的朋友就知道，即使是一句简单的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i++;</span><br></pre></td></tr></table></figure>\n<p>也往往不是一个指令完成的，可能是这样的三个指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, [esi + 1]</span><br><span class=\"line\">add eax, 1</span><br><span class=\"line\">mov [esi + 1], eax</span><br></pre></td></tr></table></figure>\n<p>假如一个线程在执行完第一句汇编以后，第二个线程开始执行第一个语句，那么结果就不对了。</p>\n<p>目前我知道的有锁、信号两种方法，但是好在Linux提供了一系列原子操作，直接用就好了。所谓原子操作中的原子，意思就和这个词的来历一样，就是指不可分割的一个操作，它要么全部不完成，要么完全生效，没有中间状态。</p>\n<h2 id=\"改文件描述符上限\"><a href=\"#改文件描述符上限\" class=\"headerlink\" title=\"改文件描述符上限\"></a>改文件描述符上限</h2><p>目前这个程序线程与连接是一个1:1的关系，在测试时我发现只要线程数目超过1000多一点，就会无法创建连接。搜索后发现是文件描述符上限的问题。</p>\n<p>在bash用命令ulimit -a就能看到文件描述符的上限（在我的Ubuntu14上是1024），如果达到这个上限就会出现无法创建新连接的情况，所以需要改一下。我按照 <a href=\"http://blog.csdn.net/kimsoft/article/details/8024216\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/kimsoft/article/details/8024216</a> 把上限改高以后就可以超过1000了。</p>\n<h1 id=\"0x2-总结与挖掘\"><a href=\"#0x2-总结与挖掘\" class=\"headerlink\" title=\"0x2 总结与挖掘\"></a>0x2 总结与挖掘</h1><p>第二篇笔记里，实现了大致以1s为周期的信息统计、多线程请求。这次学习中，我觉得还能深挖的东西有：</p>\n<ul>\n<li>我在提升文件描述符上限后又遇到另一个问题，就是数量达到大概13000的时候出现了Broken pipe的错误，在提升虚拟机配置后问题有所缓解，但是形成原理目前没有头绪。</li>\n<li>在提升配置后，虽然没有出现错误，但是线程和连接数无法达到1:1的关系了，比如输入./a.out 50000 1000000后，每秒连接数量大致稳定在2w3左右，但是即使是拿主机而非虚拟机访问服务器也是很流畅的，也就是说瓶颈应该还是在我的程序中，但是瓶颈究竟在哪里？</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"0x0-学习资料\"><a href=\"#0x0-学习资料\" class=\"headerlink\" title=\"0x0 学习资料\"></a>0x0 学习资料</h1><p><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/</a></p>\n<p><a href=\"http://man7.org/index.html\" target=\"_blank\" rel=\"noopener\">http://man7.org/index.html</a></p>\n<p>《Linux/UNIX系统编程手册》</p>\n<p>《UNIX网络编程 卷1：套接字API（第三版）》</p>\n<h1 id=\"0x1-已加入多线程豪华套餐\"><a href=\"#0x1-已加入多线程豪华套餐\" class=\"headerlink\" title=\"0x1 已加入多线程豪华套餐\"></a>0x1 已加入多线程豪华套餐</h1><p>还是先把代码放出来慢慢分析</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;asm/errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> READ_TIMEOUT_S 3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> READ_TIMEOUT_US 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WRITE_TIMEOUT_S 3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WRITE_TIMEOUT_US 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WAIT_COUNT_MAX 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> file_descriptor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> response[<span class=\"number\">1024</span>];</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_total = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_max_total = <span class=\"number\">100000</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_con = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_request_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> g_complete = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> request_lenth;</span><br><span class=\"line\"><span class=\"keyword\">pthread_t</span> g_print_thread;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port = <span class=\"number\">80</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> *host = <span class=\"string\">\"localhost\"</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">server</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">serverAddr</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> *request = <span class=\"string\">\"GET http://10.10.10.138/ HTTP/1.1\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Host: 10.10.10.138\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Connection: keep-alive\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Cache-Control: max-age=0\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Upgrade-Insecure-Requests: 1\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept-Encoding: gzip, deflate\\r\\n\"</span></span><br><span class=\"line\">        <span class=\"string\">\"Accept-Language: zh-CN,zh;q=0.9,en;q=0.8\\r\\n\\r\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">print_condition</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">cur_time</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        gettimeofday(&amp;cur_time, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"%5d\\t%21ld\\t%25d\\t%16d\\n\"</span>,index, cur_time.tv_sec*<span class=\"number\">1000000</span> + cur_time.tv_usec, g_con, g_total);</span><br><span class=\"line\">        __sync_and_and_fetch(&amp;g_con, <span class=\"number\">0</span>);</span><br><span class=\"line\">        ++index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_print_thread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_create(&amp;g_print_thread, <span class=\"literal\">NULL</span>, print_condition, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">make_socket</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    file_descriptor sock;</span><br><span class=\"line\"></span><br><span class=\"line\">    sock = socket(AF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sock &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Create socket error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sock;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">connect_server</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(connect(sock, (struct sockaddr *)&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr)) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Connect server error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_block_filedes_timeout</span><span class=\"params\">(file_descriptor filedes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_out</span>, <span class=\"title\">tv_in</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tv_in.tv_sec = READ_TIMEOUT_S;</span><br><span class=\"line\">    tv_in.tv_usec = READ_TIMEOUT_US;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setsockopt(filedes, SOL_SOCKET, SO_RCVTIMEO, &amp;tv_in, <span class=\"keyword\">sizeof</span>(tv_in)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"set rcv timeout error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tv_out.tv_sec = WRITE_TIMEOUT_S;</span><br><span class=\"line\">    tv_out.tv_usec = WRITE_TIMEOUT_US;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (setsockopt(filedes, SOL_SOCKET, SO_SNDTIMEO, &amp;tv_out, <span class=\"keyword\">sizeof</span>(tv_out)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"set rcv timeout error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">is_nonblock</span><span class=\"params\">(file_descriptor fd)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flags == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"get fd flags error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (flags &amp; O_NONBLOCK) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket_write</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nbytes;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wait_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> send_suc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        nbytes = send(sock, request, request_lenth, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is_nonblock(sock)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (wait_count &lt; WAIT_COUNT_MAX) &#123;</span><br><span class=\"line\">                        ++wait_count;</span><br><span class=\"line\">                        usleep(wait_count);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nbytes == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nbytes == request_lenth)&#123;</span><br><span class=\"line\">            send_suc = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> send_suc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket_read</span><span class=\"params\">(file_descriptor sock)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nbytes;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> wait_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> recv_suc = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        nbytes = recv(sock, response, <span class=\"keyword\">sizeof</span>(response) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is_nonblock(sock)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (EAGAIN == errno || EWOULDBLOCK == errno || EINTR == errno)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (wait_count &lt; WAIT_COUNT_MAX) &#123;</span><br><span class=\"line\">                        wait_count++;</span><br><span class=\"line\">                        usleep(wait_count);</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nbytes == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nbytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            recv_suc = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> recv_suc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">thread_connetion</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    file_descriptor socket;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(__sync_fetch_and_add(&amp;g_total, <span class=\"number\">1</span>) &lt; g_max_total)&#123;</span><br><span class=\"line\">        __sync_fetch_and_add(&amp;g_con, <span class=\"number\">1</span>);</span><br><span class=\"line\">        socket = make_socket();</span><br><span class=\"line\">        connect_server(socket);</span><br><span class=\"line\">        set_block_filedes_timeout(socket);</span><br><span class=\"line\">        __sync_fetch_and_add(&amp;g_request_count, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!socket_write(socket))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!socket_read(socket))&#123;</span><br><span class=\"line\">                __sync_fetch_and_add(&amp;g_complete, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        close(socket);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_server</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    server = gethostbyname(host);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(server == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bzero(&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(port);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;serverAddr.sin_addr.s_addr, server-&gt;h_addr, server-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">usage</span><span class=\"params\">(<span class=\"keyword\">char</span> *name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Usage: %s [thread_count] [total_connection]\\nDue to limitation of number of file descriptor, thread count should not greater than 1024.\\n\"</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> thread_count;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> thread_id;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    request_lenth = <span class=\"built_in\">strlen</span>(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(argc != <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">        usage(argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    thread_count = atoi(argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    g_max_total = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    err = init_print_thread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = init_server();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        perror(<span class=\"string\">\"No such host\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; thread_count; ++index)&#123;</span><br><span class=\"line\">        err = pthread_create(&amp;thread_id, <span class=\"literal\">NULL</span>, thread_connetion, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(g_print_thread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_SUCCESS);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来会按照函数调用关系从整体到细节来分析这个程序</p>\n<h2 id=\"主函数\"><a href=\"#主函数\" class=\"headerlink\" title=\"主函数\"></a>主函数</h2><p>首先是加入了可控的参数，一个是线程数，另一个是总连接数，使用方法不对的时候调用usage()输出用法并退出程序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">usage</span><span class=\"params\">(<span class=\"keyword\">char</span> *name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Usage: %s [thread_count] [total_connection]\\nDue to limitation of number of file descriptor, thread count should not greater than 1024.\\n\"</span>, name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能直观观察连接情况，所以在执行之前，启动一个打印统计信息的现场，同时这个线程之后还要继续用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err = init_print_thread();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果统计都搞不了，那这个测试也没用了，所以失败直接退出。</p>\n<p>函数定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_print_thread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pthread_create(&amp;g_print_thread, <span class=\"literal\">NULL</span>, print_condition, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">print_condition</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">cur_time</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"index\\tseconds_micro_seconds\\tconnection_in_this_second\\ttotal_connection\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(g_total &lt; g_max_total) &#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        gettimeofday(&amp;cur_time, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"%5d\\t%21ld\\t%25d\\t%16d\\n\"</span>,index, cur_time.tv_sec*<span class=\"number\">1000000</span> + cur_time.tv_usec, g_con, g_total);</span><br><span class=\"line\">        __sync_and_and_fetch(&amp;g_con, <span class=\"number\">0</span>);</span><br><span class=\"line\">        ++index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印的参数中，g_con是这一秒完成的连接数量（发生请求并接受响应成功计一次连接），g_total为目前的总连接数。</p>\n<p>考虑到我们只是想进行压力测试，所以对并不想保留数据，而且发起连接的信息都是一样的，所以也可以看到，之前的int port、char *host = “localhost”、struct hostent *server、struct sockaddr_in serverAddr都变成了全局变量，在创建连接前对其进行初始化。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err = init_server();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    perror(<span class=\"string\">\"No such host\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>init_server()的内容就是之前的直接搬了过来</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">init_server</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    server = gethostbyname(host);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(server == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    bzero(&amp;serverAddr, <span class=\"keyword\">sizeof</span>(serverAddr));</span><br><span class=\"line\">    serverAddr.sin_family = AF_INET;</span><br><span class=\"line\">    serverAddr.sin_port = htons(port);</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(&amp;serverAddr.sin_addr.s_addr, server-&gt;h_addr, server-&gt;h_length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后就创建传入参数个线程</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (index = <span class=\"number\">0</span>; index &lt; thread_count; ++index)&#123;</span><br><span class=\"line\">     err = pthread_create(&amp;thread_id, <span class=\"literal\">NULL</span>, thread_connetion, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(err &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">         perror(<span class=\"string\">\"Create print thread error\"</span>);</span><br><span class=\"line\">         <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>最后用在打印的线程中判断是否结束，达到连接总数后结束</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_join(g_print_thread, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程，启动！\"><a href=\"#线程，启动！\" class=\"headerlink\" title=\"线程，启动！\"></a>线程，启动！</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">thread_connetion</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span>&#123;</span><br><span class=\"line\">    file_descriptor socket;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(__sync_fetch_and_add(&amp;g_total, <span class=\"number\">1</span>) &lt; g_max_total)&#123;</span><br><span class=\"line\">        __sync_fetch_and_add(&amp;g_con, <span class=\"number\">1</span>);</span><br><span class=\"line\">        socket = make_socket();</span><br><span class=\"line\">        connect_server(socket);</span><br><span class=\"line\">        set_block_filedes_timeout(socket);</span><br><span class=\"line\">        __sync_fetch_and_add(&amp;g_request_count, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!socket_write(socket))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!socket_read(socket))&#123;</span><br><span class=\"line\">                __sync_fetch_and_add(&amp;g_complete, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        close(socket);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于个线程来说，要做的就是两件事，一个是http连接，另一个是计数。</p>\n<p>好消息是http连接用的函数都是线程安全的（根据书上写的，没有看SUSv3），所以前者就是把之前的事情放进函数体就好了。</p>\n<p>还有一些改动，比如判断是否阻塞，设置超时时限，这个是为了之后在实现I/O复用的时候复用这些函数。</p>\n<p>而后面一个操作需要考虑计数所用的变量肯定是各个线程都有的，所以必须要进行处理。</p>\n<p>学了汇编的朋友就知道，即使是一句简单的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i++;</span><br></pre></td></tr></table></figure>\n<p>也往往不是一个指令完成的，可能是这样的三个指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov eax, [esi + 1]</span><br><span class=\"line\">add eax, 1</span><br><span class=\"line\">mov [esi + 1], eax</span><br></pre></td></tr></table></figure>\n<p>假如一个线程在执行完第一句汇编以后，第二个线程开始执行第一个语句，那么结果就不对了。</p>\n<p>目前我知道的有锁、信号两种方法，但是好在Linux提供了一系列原子操作，直接用就好了。所谓原子操作中的原子，意思就和这个词的来历一样，就是指不可分割的一个操作，它要么全部不完成，要么完全生效，没有中间状态。</p>\n<h2 id=\"改文件描述符上限\"><a href=\"#改文件描述符上限\" class=\"headerlink\" title=\"改文件描述符上限\"></a>改文件描述符上限</h2><p>目前这个程序线程与连接是一个1:1的关系，在测试时我发现只要线程数目超过1000多一点，就会无法创建连接。搜索后发现是文件描述符上限的问题。</p>\n<p>在bash用命令ulimit -a就能看到文件描述符的上限（在我的Ubuntu14上是1024），如果达到这个上限就会出现无法创建新连接的情况，所以需要改一下。我按照 <a href=\"http://blog.csdn.net/kimsoft/article/details/8024216\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/kimsoft/article/details/8024216</a> 把上限改高以后就可以超过1000了。</p>\n<h1 id=\"0x2-总结与挖掘\"><a href=\"#0x2-总结与挖掘\" class=\"headerlink\" title=\"0x2 总结与挖掘\"></a>0x2 总结与挖掘</h1><p>第二篇笔记里，实现了大致以1s为周期的信息统计、多线程请求。这次学习中，我觉得还能深挖的东西有：</p>\n<ul>\n<li>我在提升文件描述符上限后又遇到另一个问题，就是数量达到大概13000的时候出现了Broken pipe的错误，在提升虚拟机配置后问题有所缓解，但是形成原理目前没有头绪。</li>\n<li>在提升配置后，虽然没有出现错误，但是线程和连接数无法达到1:1的关系了，比如输入./a.out 50000 1000000后，每秒连接数量大致稳定在2w3左右，但是即使是拿主机而非虚拟机访问服务器也是很流畅的，也就是说瓶颈应该还是在我的程序中，但是瓶颈究竟在哪里？</li>\n</ul>\n"},{"title":"新坑挖填状态","connments":true,"date":"2018-02-17T13:45:15.000Z","desc":null,"summary":"记录自己挖坑填坑状态","_content":"\n\n\n- [x] [工具]清理.exe文件\n\n曾经用C/C++打ACM（现在也偶尔写写水题混抽奖资格），编译完的可执行文件从没清理过，导致代码文件夹膨胀\n\n---\n\n其实很简单，就是在ACM代码文件夹里执行一行cmd命令\n\n```batch\ndel /S /F /Q *.exe\n```\n\n- [ ] [工具]软件备份自动化\n\n\n听起来有点痴人说梦，我也觉得有点难，可能需要定制吧\n\n\n- [ ] [比赛]信息安全创新竞赛\n\n\n人心不足蛇吞象，坑挖大了填死慢\n\n\n- [ ] ​To be continue...","source":"_posts/新坑挖填状态.md","raw":"---\ntitle: 新坑挖填状态\nconnments: true\ndate: 2018-02-17 21:45:15\ntags: Tools\ncategories: Notes\ndesc:\nsummary: 记录自己挖坑填坑状态\n---\n\n\n\n- [x] [工具]清理.exe文件\n\n曾经用C/C++打ACM（现在也偶尔写写水题混抽奖资格），编译完的可执行文件从没清理过，导致代码文件夹膨胀\n\n---\n\n其实很简单，就是在ACM代码文件夹里执行一行cmd命令\n\n```batch\ndel /S /F /Q *.exe\n```\n\n- [ ] [工具]软件备份自动化\n\n\n听起来有点痴人说梦，我也觉得有点难，可能需要定制吧\n\n\n- [ ] [比赛]信息安全创新竞赛\n\n\n人心不足蛇吞象，坑挖大了填死慢\n\n\n- [ ] ​To be continue...","slug":"新坑挖填状态","published":1,"updated":"2018-02-21T06:53:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgqnsczx000fdkudzye59bn9","content":"<ul>\n<li>[x] [工具]清理.exe文件</li>\n</ul>\n<p>曾经用C/C++打ACM（现在也偶尔写写水题混抽奖资格），编译完的可执行文件从没清理过，导致代码文件夹膨胀</p>\n<hr>\n<p>其实很简单，就是在ACM代码文件夹里执行一行cmd命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">del /S /F /Q *.exe</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[ ] [工具]软件备份自动化</li>\n</ul>\n<p>听起来有点痴人说梦，我也觉得有点难，可能需要定制吧</p>\n<ul>\n<li>[ ] [比赛]信息安全创新竞赛</li>\n</ul>\n<p>人心不足蛇吞象，坑挖大了填死慢</p>\n<ul>\n<li>[ ] ​To be continue…</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>[x] [工具]清理.exe文件</li>\n</ul>\n<p>曾经用C/C++打ACM（现在也偶尔写写水题混抽奖资格），编译完的可执行文件从没清理过，导致代码文件夹膨胀</p>\n<hr>\n<p>其实很简单，就是在ACM代码文件夹里执行一行cmd命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">del /S /F /Q *.exe</span><br></pre></td></tr></table></figure>\n<ul>\n<li>[ ] [工具]软件备份自动化</li>\n</ul>\n<p>听起来有点痴人说梦，我也觉得有点难，可能需要定制吧</p>\n<ul>\n<li>[ ] [比赛]信息安全创新竞赛</li>\n</ul>\n<p>人心不足蛇吞象，坑挖大了填死慢</p>\n<ul>\n<li>[ ] ​To be continue…</li>\n</ul>\n"},{"title":"区块链学习笔记（二）","connments":true,"date":"2018-01-21T11:35:50.000Z","desc":null,"mathjax":true,"summary":"比特币证明了在金融领域里使用一个节点组成，伴随着公共记账本陪同(accompanied by a public ledger)的分布式网络实现可信可审计计算是可能的。在这篇论文中，我们描述了一种分布式的个人数据管理系统，这个系统保证用户拥有并且控制他们自己的数据。我们使用了一种协议，这种协议使用区块链技术作为不需要可信第三方的自动的访问控制管理器。","_content":"\n## 学习资料：\n\n[Decentralizing Privacy: Using Blockchain to Protect Personal Data](https://www.computer.org/csdl/proceedings/spw/2015/9933/00/9933a180.pdf)\n\n## 学习笔记：\n\n**采用原文-自己理解的方式记录，原文部分可能经过拼装。**\n\n>    　　比特币证明了在金融领域里使用一个节点组成，伴随着公共记账本陪同(accompanied by a public ledger)的分布式网络实现可信可审计计算是可能的。在这篇论文中，我们描述了一种分布式的个人数据管理系统，这个系统保证用户拥有并且控制他们自己的数据。我们使用了一种协议，这种协议使用区块链技术作为不需要可信第三方的自动的访问控制管理器。\n\n　　论文综述。\n\n>    　　从安全的角度看，研究人员开发了一些针对个人信息的隐私顾虑的技术。数据匿名化方法尝试保护个人的可识别信息。k-匿名(k-anonymity)，匿名数据集的一个共同属性要求每个记录的敏感信息与其他的至少k-1个记录无法区分。(a common property  of anonymized datasets requires that sensitive information of  each record is indistinguishable from at least k−1 other records.)与k匿名相关的拓展有l-多样性(l-diversity)，它保证敏感数据被一个足够多样化的值的集合来表示；以及t-临近(t-closeness,网上没找到译名)，它关注敏感数据的分布。最近的研究说明了怎么样把使用了这些技术的匿名数据集去匿名化，在给出了即使是一个小数量的数据点或者高维数的数据。其他维持隐私的方法包括差分隐私，一种扰乱数据或者在分享数据前的计算过程中加入早上，以及允许在加密数据上进行计算和查询的加密方案。特别指出，完全同态加密(FHE, fully homomorphic encryption)方案允许在加密的数据上进行任何计算，但是现在在目前阶段效率过于低下以至于无法广泛用于实践。\n\n　　现阶段研究综述。\n\n>    　　在整篇论文中，我们关注并解决当用户使用第三方服务时面对的隐私忧虑。我们专注于移动平台，在其中服务部署应用程序供用户安装(where services deploy applications for users to install)。这些应用持续地收集高分辨度的个人数据，而对这些数据用户既没有具体的认知又没有控制权限。在我们的分析中，我们假定服务是*诚实但好奇的*。注意同样的系统也可以用处理其他数据隐私顾虑，比如病人分享他们的医疗数据供科学研究，但同时又拥有监督被使用过程的工具和随时选择退出的能力。有鉴于此，我们的系统将从这些常见的隐私问题中提供保护：\n>\n>    　　**数据所有权(Data Ownership)**。我们的框架关注保证用户拥有并能控制他们的个人数据。因此，这个系统将用户视为数据的拥有者，将服务视为有下放许可的访客。\n>\n>    　　**数据透明度和可审计性(Data Transparency and Auditability)**。每个用户对其数据是如何收集的以及如何访问的完全知晓。\n>\n>    　　**细粒度的访问控制(Fine-grained Access Control)**。移动端应用的一个主要问题是用户需要在注册时授予一组权限。这些许可是无限期授予的，唯一改变协议的方法就是选择退出。相反，在我们的框架中，在任何给定的时间，用户都可以改变权限集合并撤销对以前数据的访问许可。这种机制的一个应用是改善移动应用程序中现有的权限对话框。虽然用户界面可能保持不变，但是访问控制策略将被安全地存储在区块链中，在其中只有用户才能更改他们。\n\n　　诚实但好奇是信息安全中的一个模型，这个模型中参与者有义务遵守协议，但是不会故意在协议执行过程中遗忘已学到的知识(knowledge that it learns)，换句话说，所有参与者都遵守协议。在做出这样的假设后，我们应当意识到，数据隐私问题决不是纯技术问题，必须要技术与立法结合，这样才能使得我们设想的方案落到实处。最后，作者提到的最后一个问题十分吸引我。此外我十分想了解在数据的存储方面能不能提出点什么相关的方案。\n\n>    　　我们首先概述我们的系统。 如图1所示，构成我们系统的三个实体是手机用户，有兴趣下载和使用应用程序；服务，这类应用程序的提供者由于运营和商业相关的原因（例如有针对性的广告，个性化服务）需要处理个人数据；节点，委托维护区块链的实体以及分布式私钥值数据存储作为奖励。 注意，虽然系统中的用户通常保持（伪）匿名，但我们可以将服务配置文件存储在区块链中，并验证其身份。\n>\n>    {% asset_img snipaste20180122_154420.jpg %}\n>\n>    　　系统本身设计如下。 区块链接受两种新的交易类型：$T_{access}$，用于访问控制管理; 和$T_{data}$，用于数据存储和检索。 这些网络操作可以很容易地集成到服务可以在开发过程中使用的移动软件开发工具包（SDK）中。\n>\n>    　　为了说明这一点，请考虑以下示例：用户安装使用我们的平台来保护其隐私的应用程序。 当用户首次注册时，会生成一个新的共享（用户，服务）身份，并将其与关联的权限用一个$T_{access}$交易发到区块链中。 手机上收集的数据（例如位置等传感器数据）使用共享加密密钥进行加密，然后用一个$T_{data}$交易发送到的区块链，然后将其传送到键值区块链存储区，同时只保留一个指向到公共总帐上数据的指针（指针是数据的SHA-256散列）。\n>\n>    　　服务和用户现在都可以使用$T_{data}$事务来查询数据，并且使用与之关联的指针（键）。然后区块链验证数字签名属于用户或服务。对于服务，也检查其访问数据的权限。最后，用户可以随时通过发布具有一组新权限的$T_{access}$事务来更改授予服务的权限，包括撤销对以前存储的数据的访问。开发一个基于网络（或移动）的仪表板，可以对数据进行概述，并且可以更改权限，这与开发集中式钱包（比如用于比特币的Coinbase）类似。 \n>\n>    　　与区块链无关的键值存储是Kademilia的一个实现，它是一个分布式散列表（或DHT），增加了使用LevelDB2实现的持久性以及区块链的接口。 DHT由完成批准的读/写事务的节点网络（可能与区块链网络不相交）维护。数据在节点间充分随机化，并进行复制以确保高可用性。注意到替代性的区块链解决方案可以被考虑用于存储是有益的。例如，可以使用集中式云来存储数据。虽然这需要在第三方中获得一定程度的信任，但在可扩展性和易部署方面具有一些优势。\n\n　　$T_{access}$是用户专用的访问权限管理用的交易，而$T_{data}$是服务与用户都可以使用的用于检索和存储数据的交易。数据使用共享密钥加密后使用$T_{data}$交易放到区块链中，保留指向公共总账数据的指针，指针是数据的SHA-256散列值。看到这里我其实有点疑惑，保留的是数据的SHA-256散列值的话，到时候要怎么访问？以及它说的区块链验证以后，怎么把数据转运？\n\n>    　　这里我们将提供在区块链上执行的核心协议的详细描述。当接收到$T_{access}$事务时，协议3由网络中的节点执行，类似地，对于$T_{data}$事务执行协议4。\n>\n>    　　正如本文前面提到的，$T_{access}$事务允许用户通过发送一个$POLICY_{u,s}$集合来更改授予服务的权限集合。发送空集撤销先前授予的所有访问权。首次发送具有新复合身份标识的$T_{access}$事务被解释为注册到服务的用户。\n>\n>    　　同样，$T_{data}$事务管理读/写操作。在$CheckPolicy$的帮助下，只有用户（总是）或服务（如果允许）才能访问数据。请注意，在协议4的第9行和第16行中，我们使用简写符号来访问$DHT$，就像正常的哈希表一样。实际上，这些指令的结果是发送给$DHT$的区块链外网络消息（读取或写入）。\n\n　　算是和预期相符，因为区块链本身的效率比较低下（考虑比特币7hz的交易频率），全部用区块链就是为用而用了。\n\n>    　　本文的主要贡献之一就是展示如何克服区块链的公共性。 到目前为止，我们的分析重点是存储指向加密数据的指针。 虽然这种方法适用于存储和随机查询，但处理数据效率不高。 更重要的是，一旦服务查询了一段原始数据，就可以将其存储起来以备将来分析。\n>\n>    　　一个更好的方法可能是永远不要让服务观察原始数据，而是让它直接在网络上运行计算并获得最终结果。 如果我们将数据分成共享（例如，使用Shamir的秘密共享协议），而不是对它们进行加密，那么我们就可以使用安全的多方计算（MPC）来安全地评估任何函数。\n\n　　这段必须摘出来的理由正是其第一段所言。","source":"_posts/区块链学习笔记（二）.md","raw":"---\ntitle: 区块链学习笔记（二）\nconnments: true\ndate: 2018-01-21 19:35:50\ntags: blockchain\ncategories: Notes\ndesc:\nmathjax: true\nsummary: 比特币证明了在金融领域里使用一个节点组成，伴随着公共记账本陪同(accompanied by a public ledger)的分布式网络实现可信可审计计算是可能的。在这篇论文中，我们描述了一种分布式的个人数据管理系统，这个系统保证用户拥有并且控制他们自己的数据。我们使用了一种协议，这种协议使用区块链技术作为不需要可信第三方的自动的访问控制管理器。\n---\n\n## 学习资料：\n\n[Decentralizing Privacy: Using Blockchain to Protect Personal Data](https://www.computer.org/csdl/proceedings/spw/2015/9933/00/9933a180.pdf)\n\n## 学习笔记：\n\n**采用原文-自己理解的方式记录，原文部分可能经过拼装。**\n\n>    　　比特币证明了在金融领域里使用一个节点组成，伴随着公共记账本陪同(accompanied by a public ledger)的分布式网络实现可信可审计计算是可能的。在这篇论文中，我们描述了一种分布式的个人数据管理系统，这个系统保证用户拥有并且控制他们自己的数据。我们使用了一种协议，这种协议使用区块链技术作为不需要可信第三方的自动的访问控制管理器。\n\n　　论文综述。\n\n>    　　从安全的角度看，研究人员开发了一些针对个人信息的隐私顾虑的技术。数据匿名化方法尝试保护个人的可识别信息。k-匿名(k-anonymity)，匿名数据集的一个共同属性要求每个记录的敏感信息与其他的至少k-1个记录无法区分。(a common property  of anonymized datasets requires that sensitive information of  each record is indistinguishable from at least k−1 other records.)与k匿名相关的拓展有l-多样性(l-diversity)，它保证敏感数据被一个足够多样化的值的集合来表示；以及t-临近(t-closeness,网上没找到译名)，它关注敏感数据的分布。最近的研究说明了怎么样把使用了这些技术的匿名数据集去匿名化，在给出了即使是一个小数量的数据点或者高维数的数据。其他维持隐私的方法包括差分隐私，一种扰乱数据或者在分享数据前的计算过程中加入早上，以及允许在加密数据上进行计算和查询的加密方案。特别指出，完全同态加密(FHE, fully homomorphic encryption)方案允许在加密的数据上进行任何计算，但是现在在目前阶段效率过于低下以至于无法广泛用于实践。\n\n　　现阶段研究综述。\n\n>    　　在整篇论文中，我们关注并解决当用户使用第三方服务时面对的隐私忧虑。我们专注于移动平台，在其中服务部署应用程序供用户安装(where services deploy applications for users to install)。这些应用持续地收集高分辨度的个人数据，而对这些数据用户既没有具体的认知又没有控制权限。在我们的分析中，我们假定服务是*诚实但好奇的*。注意同样的系统也可以用处理其他数据隐私顾虑，比如病人分享他们的医疗数据供科学研究，但同时又拥有监督被使用过程的工具和随时选择退出的能力。有鉴于此，我们的系统将从这些常见的隐私问题中提供保护：\n>\n>    　　**数据所有权(Data Ownership)**。我们的框架关注保证用户拥有并能控制他们的个人数据。因此，这个系统将用户视为数据的拥有者，将服务视为有下放许可的访客。\n>\n>    　　**数据透明度和可审计性(Data Transparency and Auditability)**。每个用户对其数据是如何收集的以及如何访问的完全知晓。\n>\n>    　　**细粒度的访问控制(Fine-grained Access Control)**。移动端应用的一个主要问题是用户需要在注册时授予一组权限。这些许可是无限期授予的，唯一改变协议的方法就是选择退出。相反，在我们的框架中，在任何给定的时间，用户都可以改变权限集合并撤销对以前数据的访问许可。这种机制的一个应用是改善移动应用程序中现有的权限对话框。虽然用户界面可能保持不变，但是访问控制策略将被安全地存储在区块链中，在其中只有用户才能更改他们。\n\n　　诚实但好奇是信息安全中的一个模型，这个模型中参与者有义务遵守协议，但是不会故意在协议执行过程中遗忘已学到的知识(knowledge that it learns)，换句话说，所有参与者都遵守协议。在做出这样的假设后，我们应当意识到，数据隐私问题决不是纯技术问题，必须要技术与立法结合，这样才能使得我们设想的方案落到实处。最后，作者提到的最后一个问题十分吸引我。此外我十分想了解在数据的存储方面能不能提出点什么相关的方案。\n\n>    　　我们首先概述我们的系统。 如图1所示，构成我们系统的三个实体是手机用户，有兴趣下载和使用应用程序；服务，这类应用程序的提供者由于运营和商业相关的原因（例如有针对性的广告，个性化服务）需要处理个人数据；节点，委托维护区块链的实体以及分布式私钥值数据存储作为奖励。 注意，虽然系统中的用户通常保持（伪）匿名，但我们可以将服务配置文件存储在区块链中，并验证其身份。\n>\n>    {% asset_img snipaste20180122_154420.jpg %}\n>\n>    　　系统本身设计如下。 区块链接受两种新的交易类型：$T_{access}$，用于访问控制管理; 和$T_{data}$，用于数据存储和检索。 这些网络操作可以很容易地集成到服务可以在开发过程中使用的移动软件开发工具包（SDK）中。\n>\n>    　　为了说明这一点，请考虑以下示例：用户安装使用我们的平台来保护其隐私的应用程序。 当用户首次注册时，会生成一个新的共享（用户，服务）身份，并将其与关联的权限用一个$T_{access}$交易发到区块链中。 手机上收集的数据（例如位置等传感器数据）使用共享加密密钥进行加密，然后用一个$T_{data}$交易发送到的区块链，然后将其传送到键值区块链存储区，同时只保留一个指向到公共总帐上数据的指针（指针是数据的SHA-256散列）。\n>\n>    　　服务和用户现在都可以使用$T_{data}$事务来查询数据，并且使用与之关联的指针（键）。然后区块链验证数字签名属于用户或服务。对于服务，也检查其访问数据的权限。最后，用户可以随时通过发布具有一组新权限的$T_{access}$事务来更改授予服务的权限，包括撤销对以前存储的数据的访问。开发一个基于网络（或移动）的仪表板，可以对数据进行概述，并且可以更改权限，这与开发集中式钱包（比如用于比特币的Coinbase）类似。 \n>\n>    　　与区块链无关的键值存储是Kademilia的一个实现，它是一个分布式散列表（或DHT），增加了使用LevelDB2实现的持久性以及区块链的接口。 DHT由完成批准的读/写事务的节点网络（可能与区块链网络不相交）维护。数据在节点间充分随机化，并进行复制以确保高可用性。注意到替代性的区块链解决方案可以被考虑用于存储是有益的。例如，可以使用集中式云来存储数据。虽然这需要在第三方中获得一定程度的信任，但在可扩展性和易部署方面具有一些优势。\n\n　　$T_{access}$是用户专用的访问权限管理用的交易，而$T_{data}$是服务与用户都可以使用的用于检索和存储数据的交易。数据使用共享密钥加密后使用$T_{data}$交易放到区块链中，保留指向公共总账数据的指针，指针是数据的SHA-256散列值。看到这里我其实有点疑惑，保留的是数据的SHA-256散列值的话，到时候要怎么访问？以及它说的区块链验证以后，怎么把数据转运？\n\n>    　　这里我们将提供在区块链上执行的核心协议的详细描述。当接收到$T_{access}$事务时，协议3由网络中的节点执行，类似地，对于$T_{data}$事务执行协议4。\n>\n>    　　正如本文前面提到的，$T_{access}$事务允许用户通过发送一个$POLICY_{u,s}$集合来更改授予服务的权限集合。发送空集撤销先前授予的所有访问权。首次发送具有新复合身份标识的$T_{access}$事务被解释为注册到服务的用户。\n>\n>    　　同样，$T_{data}$事务管理读/写操作。在$CheckPolicy$的帮助下，只有用户（总是）或服务（如果允许）才能访问数据。请注意，在协议4的第9行和第16行中，我们使用简写符号来访问$DHT$，就像正常的哈希表一样。实际上，这些指令的结果是发送给$DHT$的区块链外网络消息（读取或写入）。\n\n　　算是和预期相符，因为区块链本身的效率比较低下（考虑比特币7hz的交易频率），全部用区块链就是为用而用了。\n\n>    　　本文的主要贡献之一就是展示如何克服区块链的公共性。 到目前为止，我们的分析重点是存储指向加密数据的指针。 虽然这种方法适用于存储和随机查询，但处理数据效率不高。 更重要的是，一旦服务查询了一段原始数据，就可以将其存储起来以备将来分析。\n>\n>    　　一个更好的方法可能是永远不要让服务观察原始数据，而是让它直接在网络上运行计算并获得最终结果。 如果我们将数据分成共享（例如，使用Shamir的秘密共享协议），而不是对它们进行加密，那么我们就可以使用安全的多方计算（MPC）来安全地评估任何函数。\n\n　　这段必须摘出来的理由正是其第一段所言。","slug":"区块链学习笔记（二）","published":1,"updated":"2018-03-15T14:37:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgqnsd03000jdkud1v44hx8u","content":"<h2 id=\"学习资料：\"><a href=\"#学习资料：\" class=\"headerlink\" title=\"学习资料：\"></a>学习资料：</h2><p><a href=\"https://www.computer.org/csdl/proceedings/spw/2015/9933/00/9933a180.pdf\" target=\"_blank\" rel=\"noopener\">Decentralizing Privacy: Using Blockchain to Protect Personal Data</a></p>\n<h2 id=\"学习笔记：\"><a href=\"#学习笔记：\" class=\"headerlink\" title=\"学习笔记：\"></a>学习笔记：</h2><p><strong>采用原文-自己理解的方式记录，原文部分可能经过拼装。</strong></p>\n<blockquote>\n<p>   　　比特币证明了在金融领域里使用一个节点组成，伴随着公共记账本陪同(accompanied by a public ledger)的分布式网络实现可信可审计计算是可能的。在这篇论文中，我们描述了一种分布式的个人数据管理系统，这个系统保证用户拥有并且控制他们自己的数据。我们使用了一种协议，这种协议使用区块链技术作为不需要可信第三方的自动的访问控制管理器。</p>\n</blockquote>\n<p>　　论文综述。</p>\n<blockquote>\n<p>   　　从安全的角度看，研究人员开发了一些针对个人信息的隐私顾虑的技术。数据匿名化方法尝试保护个人的可识别信息。k-匿名(k-anonymity)，匿名数据集的一个共同属性要求每个记录的敏感信息与其他的至少k-1个记录无法区分。(a common property  of anonymized datasets requires that sensitive information of  each record is indistinguishable from at least k−1 other records.)与k匿名相关的拓展有l-多样性(l-diversity)，它保证敏感数据被一个足够多样化的值的集合来表示；以及t-临近(t-closeness,网上没找到译名)，它关注敏感数据的分布。最近的研究说明了怎么样把使用了这些技术的匿名数据集去匿名化，在给出了即使是一个小数量的数据点或者高维数的数据。其他维持隐私的方法包括差分隐私，一种扰乱数据或者在分享数据前的计算过程中加入早上，以及允许在加密数据上进行计算和查询的加密方案。特别指出，完全同态加密(FHE, fully homomorphic encryption)方案允许在加密的数据上进行任何计算，但是现在在目前阶段效率过于低下以至于无法广泛用于实践。</p>\n</blockquote>\n<p>　　现阶段研究综述。</p>\n<blockquote>\n<p>   　　在整篇论文中，我们关注并解决当用户使用第三方服务时面对的隐私忧虑。我们专注于移动平台，在其中服务部署应用程序供用户安装(where services deploy applications for users to install)。这些应用持续地收集高分辨度的个人数据，而对这些数据用户既没有具体的认知又没有控制权限。在我们的分析中，我们假定服务是<em>诚实但好奇的</em>。注意同样的系统也可以用处理其他数据隐私顾虑，比如病人分享他们的医疗数据供科学研究，但同时又拥有监督被使用过程的工具和随时选择退出的能力。有鉴于此，我们的系统将从这些常见的隐私问题中提供保护：</p>\n<p>   　　<strong>数据所有权(Data Ownership)</strong>。我们的框架关注保证用户拥有并能控制他们的个人数据。因此，这个系统将用户视为数据的拥有者，将服务视为有下放许可的访客。</p>\n<p>   　　<strong>数据透明度和可审计性(Data Transparency and Auditability)</strong>。每个用户对其数据是如何收集的以及如何访问的完全知晓。</p>\n<p>   　　<strong>细粒度的访问控制(Fine-grained Access Control)</strong>。移动端应用的一个主要问题是用户需要在注册时授予一组权限。这些许可是无限期授予的，唯一改变协议的方法就是选择退出。相反，在我们的框架中，在任何给定的时间，用户都可以改变权限集合并撤销对以前数据的访问许可。这种机制的一个应用是改善移动应用程序中现有的权限对话框。虽然用户界面可能保持不变，但是访问控制策略将被安全地存储在区块链中，在其中只有用户才能更改他们。</p>\n</blockquote>\n<p>　　诚实但好奇是信息安全中的一个模型，这个模型中参与者有义务遵守协议，但是不会故意在协议执行过程中遗忘已学到的知识(knowledge that it learns)，换句话说，所有参与者都遵守协议。在做出这样的假设后，我们应当意识到，数据隐私问题决不是纯技术问题，必须要技术与立法结合，这样才能使得我们设想的方案落到实处。最后，作者提到的最后一个问题十分吸引我。此外我十分想了解在数据的存储方面能不能提出点什么相关的方案。</p>\n<blockquote>\n<p>   　　我们首先概述我们的系统。 如图1所示，构成我们系统的三个实体是手机用户，有兴趣下载和使用应用程序；服务，这类应用程序的提供者由于运营和商业相关的原因（例如有针对性的广告，个性化服务）需要处理个人数据；节点，委托维护区块链的实体以及分布式私钥值数据存储作为奖励。 注意，虽然系统中的用户通常保持（伪）匿名，但我们可以将服务配置文件存储在区块链中，并验证其身份。</p>\n   <img src=\"/2018/01/21/区块链学习笔记（二）/snipaste20180122_154420.jpg\">\n<p>   　　系统本身设计如下。 区块链接受两种新的交易类型：$T_{access}$，用于访问控制管理; 和$T_{data}$，用于数据存储和检索。 这些网络操作可以很容易地集成到服务可以在开发过程中使用的移动软件开发工具包（SDK）中。</p>\n<p>   　　为了说明这一点，请考虑以下示例：用户安装使用我们的平台来保护其隐私的应用程序。 当用户首次注册时，会生成一个新的共享（用户，服务）身份，并将其与关联的权限用一个$T_{access}$交易发到区块链中。 手机上收集的数据（例如位置等传感器数据）使用共享加密密钥进行加密，然后用一个$T_{data}$交易发送到的区块链，然后将其传送到键值区块链存储区，同时只保留一个指向到公共总帐上数据的指针（指针是数据的SHA-256散列）。</p>\n<p>   　　服务和用户现在都可以使用$T_{data}$事务来查询数据，并且使用与之关联的指针（键）。然后区块链验证数字签名属于用户或服务。对于服务，也检查其访问数据的权限。最后，用户可以随时通过发布具有一组新权限的$T_{access}$事务来更改授予服务的权限，包括撤销对以前存储的数据的访问。开发一个基于网络（或移动）的仪表板，可以对数据进行概述，并且可以更改权限，这与开发集中式钱包（比如用于比特币的Coinbase）类似。 </p>\n<p>   　　与区块链无关的键值存储是Kademilia的一个实现，它是一个分布式散列表（或DHT），增加了使用LevelDB2实现的持久性以及区块链的接口。 DHT由完成批准的读/写事务的节点网络（可能与区块链网络不相交）维护。数据在节点间充分随机化，并进行复制以确保高可用性。注意到替代性的区块链解决方案可以被考虑用于存储是有益的。例如，可以使用集中式云来存储数据。虽然这需要在第三方中获得一定程度的信任，但在可扩展性和易部署方面具有一些优势。</p>\n</blockquote>\n<p>　　$T_{access}$是用户专用的访问权限管理用的交易，而$T_{data}$是服务与用户都可以使用的用于检索和存储数据的交易。数据使用共享密钥加密后使用$T_{data}$交易放到区块链中，保留指向公共总账数据的指针，指针是数据的SHA-256散列值。看到这里我其实有点疑惑，保留的是数据的SHA-256散列值的话，到时候要怎么访问？以及它说的区块链验证以后，怎么把数据转运？</p>\n<blockquote>\n<p>   　　这里我们将提供在区块链上执行的核心协议的详细描述。当接收到$T_{access}$事务时，协议3由网络中的节点执行，类似地，对于$T_{data}$事务执行协议4。</p>\n<p>   　　正如本文前面提到的，$T_{access}$事务允许用户通过发送一个$POLICY_{u,s}$集合来更改授予服务的权限集合。发送空集撤销先前授予的所有访问权。首次发送具有新复合身份标识的$T_{access}$事务被解释为注册到服务的用户。</p>\n<p>   　　同样，$T_{data}$事务管理读/写操作。在$CheckPolicy$的帮助下，只有用户（总是）或服务（如果允许）才能访问数据。请注意，在协议4的第9行和第16行中，我们使用简写符号来访问$DHT$，就像正常的哈希表一样。实际上，这些指令的结果是发送给$DHT$的区块链外网络消息（读取或写入）。</p>\n</blockquote>\n<p>　　算是和预期相符，因为区块链本身的效率比较低下（考虑比特币7hz的交易频率），全部用区块链就是为用而用了。</p>\n<blockquote>\n<p>   　　本文的主要贡献之一就是展示如何克服区块链的公共性。 到目前为止，我们的分析重点是存储指向加密数据的指针。 虽然这种方法适用于存储和随机查询，但处理数据效率不高。 更重要的是，一旦服务查询了一段原始数据，就可以将其存储起来以备将来分析。</p>\n<p>   　　一个更好的方法可能是永远不要让服务观察原始数据，而是让它直接在网络上运行计算并获得最终结果。 如果我们将数据分成共享（例如，使用Shamir的秘密共享协议），而不是对它们进行加密，那么我们就可以使用安全的多方计算（MPC）来安全地评估任何函数。</p>\n</blockquote>\n<p>　　这段必须摘出来的理由正是其第一段所言。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"学习资料：\"><a href=\"#学习资料：\" class=\"headerlink\" title=\"学习资料：\"></a>学习资料：</h2><p><a href=\"https://www.computer.org/csdl/proceedings/spw/2015/9933/00/9933a180.pdf\" target=\"_blank\" rel=\"noopener\">Decentralizing Privacy: Using Blockchain to Protect Personal Data</a></p>\n<h2 id=\"学习笔记：\"><a href=\"#学习笔记：\" class=\"headerlink\" title=\"学习笔记：\"></a>学习笔记：</h2><p><strong>采用原文-自己理解的方式记录，原文部分可能经过拼装。</strong></p>\n<blockquote>\n<p>   　　比特币证明了在金融领域里使用一个节点组成，伴随着公共记账本陪同(accompanied by a public ledger)的分布式网络实现可信可审计计算是可能的。在这篇论文中，我们描述了一种分布式的个人数据管理系统，这个系统保证用户拥有并且控制他们自己的数据。我们使用了一种协议，这种协议使用区块链技术作为不需要可信第三方的自动的访问控制管理器。</p>\n</blockquote>\n<p>　　论文综述。</p>\n<blockquote>\n<p>   　　从安全的角度看，研究人员开发了一些针对个人信息的隐私顾虑的技术。数据匿名化方法尝试保护个人的可识别信息。k-匿名(k-anonymity)，匿名数据集的一个共同属性要求每个记录的敏感信息与其他的至少k-1个记录无法区分。(a common property  of anonymized datasets requires that sensitive information of  each record is indistinguishable from at least k−1 other records.)与k匿名相关的拓展有l-多样性(l-diversity)，它保证敏感数据被一个足够多样化的值的集合来表示；以及t-临近(t-closeness,网上没找到译名)，它关注敏感数据的分布。最近的研究说明了怎么样把使用了这些技术的匿名数据集去匿名化，在给出了即使是一个小数量的数据点或者高维数的数据。其他维持隐私的方法包括差分隐私，一种扰乱数据或者在分享数据前的计算过程中加入早上，以及允许在加密数据上进行计算和查询的加密方案。特别指出，完全同态加密(FHE, fully homomorphic encryption)方案允许在加密的数据上进行任何计算，但是现在在目前阶段效率过于低下以至于无法广泛用于实践。</p>\n</blockquote>\n<p>　　现阶段研究综述。</p>\n<blockquote>\n<p>   　　在整篇论文中，我们关注并解决当用户使用第三方服务时面对的隐私忧虑。我们专注于移动平台，在其中服务部署应用程序供用户安装(where services deploy applications for users to install)。这些应用持续地收集高分辨度的个人数据，而对这些数据用户既没有具体的认知又没有控制权限。在我们的分析中，我们假定服务是<em>诚实但好奇的</em>。注意同样的系统也可以用处理其他数据隐私顾虑，比如病人分享他们的医疗数据供科学研究，但同时又拥有监督被使用过程的工具和随时选择退出的能力。有鉴于此，我们的系统将从这些常见的隐私问题中提供保护：</p>\n<p>   　　<strong>数据所有权(Data Ownership)</strong>。我们的框架关注保证用户拥有并能控制他们的个人数据。因此，这个系统将用户视为数据的拥有者，将服务视为有下放许可的访客。</p>\n<p>   　　<strong>数据透明度和可审计性(Data Transparency and Auditability)</strong>。每个用户对其数据是如何收集的以及如何访问的完全知晓。</p>\n<p>   　　<strong>细粒度的访问控制(Fine-grained Access Control)</strong>。移动端应用的一个主要问题是用户需要在注册时授予一组权限。这些许可是无限期授予的，唯一改变协议的方法就是选择退出。相反，在我们的框架中，在任何给定的时间，用户都可以改变权限集合并撤销对以前数据的访问许可。这种机制的一个应用是改善移动应用程序中现有的权限对话框。虽然用户界面可能保持不变，但是访问控制策略将被安全地存储在区块链中，在其中只有用户才能更改他们。</p>\n</blockquote>\n<p>　　诚实但好奇是信息安全中的一个模型，这个模型中参与者有义务遵守协议，但是不会故意在协议执行过程中遗忘已学到的知识(knowledge that it learns)，换句话说，所有参与者都遵守协议。在做出这样的假设后，我们应当意识到，数据隐私问题决不是纯技术问题，必须要技术与立法结合，这样才能使得我们设想的方案落到实处。最后，作者提到的最后一个问题十分吸引我。此外我十分想了解在数据的存储方面能不能提出点什么相关的方案。</p>\n<blockquote>\n<p>   　　我们首先概述我们的系统。 如图1所示，构成我们系统的三个实体是手机用户，有兴趣下载和使用应用程序；服务，这类应用程序的提供者由于运营和商业相关的原因（例如有针对性的广告，个性化服务）需要处理个人数据；节点，委托维护区块链的实体以及分布式私钥值数据存储作为奖励。 注意，虽然系统中的用户通常保持（伪）匿名，但我们可以将服务配置文件存储在区块链中，并验证其身份。</p>\n   <img src=\"/2018/01/21/区块链学习笔记（二）/snipaste20180122_154420.jpg\">\n<p>   　　系统本身设计如下。 区块链接受两种新的交易类型：$T_{access}$，用于访问控制管理; 和$T_{data}$，用于数据存储和检索。 这些网络操作可以很容易地集成到服务可以在开发过程中使用的移动软件开发工具包（SDK）中。</p>\n<p>   　　为了说明这一点，请考虑以下示例：用户安装使用我们的平台来保护其隐私的应用程序。 当用户首次注册时，会生成一个新的共享（用户，服务）身份，并将其与关联的权限用一个$T_{access}$交易发到区块链中。 手机上收集的数据（例如位置等传感器数据）使用共享加密密钥进行加密，然后用一个$T_{data}$交易发送到的区块链，然后将其传送到键值区块链存储区，同时只保留一个指向到公共总帐上数据的指针（指针是数据的SHA-256散列）。</p>\n<p>   　　服务和用户现在都可以使用$T_{data}$事务来查询数据，并且使用与之关联的指针（键）。然后区块链验证数字签名属于用户或服务。对于服务，也检查其访问数据的权限。最后，用户可以随时通过发布具有一组新权限的$T_{access}$事务来更改授予服务的权限，包括撤销对以前存储的数据的访问。开发一个基于网络（或移动）的仪表板，可以对数据进行概述，并且可以更改权限，这与开发集中式钱包（比如用于比特币的Coinbase）类似。 </p>\n<p>   　　与区块链无关的键值存储是Kademilia的一个实现，它是一个分布式散列表（或DHT），增加了使用LevelDB2实现的持久性以及区块链的接口。 DHT由完成批准的读/写事务的节点网络（可能与区块链网络不相交）维护。数据在节点间充分随机化，并进行复制以确保高可用性。注意到替代性的区块链解决方案可以被考虑用于存储是有益的。例如，可以使用集中式云来存储数据。虽然这需要在第三方中获得一定程度的信任，但在可扩展性和易部署方面具有一些优势。</p>\n</blockquote>\n<p>　　$T_{access}$是用户专用的访问权限管理用的交易，而$T_{data}$是服务与用户都可以使用的用于检索和存储数据的交易。数据使用共享密钥加密后使用$T_{data}$交易放到区块链中，保留指向公共总账数据的指针，指针是数据的SHA-256散列值。看到这里我其实有点疑惑，保留的是数据的SHA-256散列值的话，到时候要怎么访问？以及它说的区块链验证以后，怎么把数据转运？</p>\n<blockquote>\n<p>   　　这里我们将提供在区块链上执行的核心协议的详细描述。当接收到$T_{access}$事务时，协议3由网络中的节点执行，类似地，对于$T_{data}$事务执行协议4。</p>\n<p>   　　正如本文前面提到的，$T_{access}$事务允许用户通过发送一个$POLICY_{u,s}$集合来更改授予服务的权限集合。发送空集撤销先前授予的所有访问权。首次发送具有新复合身份标识的$T_{access}$事务被解释为注册到服务的用户。</p>\n<p>   　　同样，$T_{data}$事务管理读/写操作。在$CheckPolicy$的帮助下，只有用户（总是）或服务（如果允许）才能访问数据。请注意，在协议4的第9行和第16行中，我们使用简写符号来访问$DHT$，就像正常的哈希表一样。实际上，这些指令的结果是发送给$DHT$的区块链外网络消息（读取或写入）。</p>\n</blockquote>\n<p>　　算是和预期相符，因为区块链本身的效率比较低下（考虑比特币7hz的交易频率），全部用区块链就是为用而用了。</p>\n<blockquote>\n<p>   　　本文的主要贡献之一就是展示如何克服区块链的公共性。 到目前为止，我们的分析重点是存储指向加密数据的指针。 虽然这种方法适用于存储和随机查询，但处理数据效率不高。 更重要的是，一旦服务查询了一段原始数据，就可以将其存储起来以备将来分析。</p>\n<p>   　　一个更好的方法可能是永远不要让服务观察原始数据，而是让它直接在网络上运行计算并获得最终结果。 如果我们将数据分成共享（例如，使用Shamir的秘密共享协议），而不是对它们进行加密，那么我们就可以使用安全的多方计算（MPC）来安全地评估任何函数。</p>\n</blockquote>\n<p>　　这段必须摘出来的理由正是其第一段所言。</p>\n"}],"PostAsset":[{"_id":"source/_posts/完成一个C语言http服务器压力测试工具（一）/FD_SIZE.png","slug":"FD_SIZE.png","post":"cjgqnsczm0007dkudzdpq45jn","modified":0,"renderable":0},{"_id":"source/_posts/区块链学习笔记（二）/snipaste20180122_154420.jpg","slug":"snipaste20180122_154420.jpg","post":"cjgqnsd03000jdkud1v44hx8u","modified":0,"renderable":0},{"_id":"source/_posts/完成一个C语言http服务器压力测试工具（三）/flowchart.png","slug":"flowchart.png","post":"cjgqnsczq000adkudjsnni7j1","modified":0,"renderable":0},{"_id":"source/_posts/完成一个C语言http服务器压力测试工具（三）/snipaste20180320_005219.png","slug":"snipaste20180320_005219.png","post":"cjgqnsczq000adkudjsnni7j1","modified":0,"renderable":0},{"_id":"source/_posts/区块链学习笔记（一）/2.jpg","slug":"2.jpg","post":"cjgqnsczk0005dkudw3a4h194","modified":0,"renderable":0},{"_id":"source/_posts/区块链学习笔记（一）/snipaste20180118_002602.jpg","slug":"snipaste20180118_002602.jpg","post":"cjgqnsczk0005dkudw3a4h194","modified":0,"renderable":0},{"_id":"source/_posts/区块链学习笔记（一）/snipaste20180118_004710.jpg","slug":"snipaste20180118_004710.jpg","post":"cjgqnsczk0005dkudw3a4h194","modified":0,"renderable":0},{"_id":"source/_posts/区块链学习笔记（一）/snipaste20180118_013210.jpg","slug":"snipaste20180118_013210.jpg","post":"cjgqnsczk0005dkudw3a4h194","modified":0,"renderable":0},{"_id":"source/_posts/区块链学习笔记（一）/新文档_2018-01-18_1.jpg","slug":"新文档_2018-01-18_1.jpg","post":"cjgqnsczk0005dkudw3a4h194","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjgqnscyv0000dkudn8zoj7rk","category_id":"cjgqnscz60001dkud24g4qt0f","_id":"cjgqnscza0004dkud41y3uq7c"},{"post_id":"cjgqnsczk0005dkudw3a4h194","category_id":"cjgqnscz60001dkud24g4qt0f","_id":"cjgqnsczu000ddkud1csc4bbp"},{"post_id":"cjgqnsczm0007dkudzdpq45jn","category_id":"cjgqnscz60001dkud24g4qt0f","_id":"cjgqnsd02000gdkudpil5mt7r"},{"post_id":"cjgqnsczq000adkudjsnni7j1","category_id":"cjgqnscz60001dkud24g4qt0f","_id":"cjgqnsd05000kdkudwlxxj41v"},{"post_id":"cjgqnsczt000cdkudfh95ed01","category_id":"cjgqnscz60001dkud24g4qt0f","_id":"cjgqnsd06000ldkud0xunhqf1"},{"post_id":"cjgqnsczx000fdkudzye59bn9","category_id":"cjgqnscz60001dkud24g4qt0f","_id":"cjgqnsd07000odkudypr1n0uv"},{"post_id":"cjgqnsd03000jdkud1v44hx8u","category_id":"cjgqnscz60001dkud24g4qt0f","_id":"cjgqnsd07000pdkudyyrifcqs"}],"PostTag":[{"post_id":"cjgqnscyv0000dkudn8zoj7rk","tag_id":"cjgqnscz70002dkud1ycxghli","_id":"cjgqnscz90003dkudk1uvtld0"},{"post_id":"cjgqnsczk0005dkudw3a4h194","tag_id":"cjgqnsczm0009dkudxt0q24sf","_id":"cjgqnsd03000idkud57cf282e"},{"post_id":"cjgqnsd03000jdkud1v44hx8u","tag_id":"cjgqnsczm0009dkudxt0q24sf","_id":"cjgqnsd07000ndkudo49ker6k"},{"post_id":"cjgqnsczm0007dkudzdpq45jn","tag_id":"cjgqnsd02000hdkudnclh06km","_id":"cjgqnsd09000rdkudflwqt9lm"},{"post_id":"cjgqnsczm0007dkudzdpq45jn","tag_id":"cjgqnsd06000mdkudryrcb538","_id":"cjgqnsd0a000sdkudvrkuemju"},{"post_id":"cjgqnsczq000adkudjsnni7j1","tag_id":"cjgqnsd02000hdkudnclh06km","_id":"cjgqnsd0b000vdkud1w68rp0t"},{"post_id":"cjgqnsczq000adkudjsnni7j1","tag_id":"cjgqnsd06000mdkudryrcb538","_id":"cjgqnsd0b000wdkudqanae10m"},{"post_id":"cjgqnsczt000cdkudfh95ed01","tag_id":"cjgqnsd02000hdkudnclh06km","_id":"cjgqnsd0i000zdkud103zx7wx"},{"post_id":"cjgqnsczt000cdkudfh95ed01","tag_id":"cjgqnsd06000mdkudryrcb538","_id":"cjgqnsd0i0010dkudd1rf191d"},{"post_id":"cjgqnsczx000fdkudzye59bn9","tag_id":"cjgqnsd0h000ydkud1n8sct35","_id":"cjgqnsd0j0011dkudyer6w5j8"}],"Tag":[{"name":"Programming","_id":"cjgqnscz70002dkud1ycxghli"},{"name":"blockchain","_id":"cjgqnsczm0009dkudxt0q24sf"},{"name":"C","_id":"cjgqnsd02000hdkudnclh06km"},{"name":"Software Development","_id":"cjgqnsd06000mdkudryrcb538"},{"name":"Tools","_id":"cjgqnsd0h000ydkud1n8sct35"}]}}